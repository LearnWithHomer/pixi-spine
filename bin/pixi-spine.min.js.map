{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/index","pixi-spine.min.js","src/Spine/index.js","src/SpineRuntime/Animation.js","src/SpineRuntime/AnimationState.js","src/SpineRuntime/AnimationStateData.js","src/SpineRuntime/Atlas.js","src/SpineRuntime/AtlasAttachmentParser.js","src/SpineRuntime/AtlasPage.js","src/SpineRuntime/AtlasReader.js","src/SpineRuntime/AtlasRegion.js","src/SpineRuntime/AttachmentTimeline.js","src/SpineRuntime/AttachmentType.js","src/SpineRuntime/Bone.js","src/SpineRuntime/BoneData.js","src/SpineRuntime/BoundingBoxAttachment.js","src/SpineRuntime/ColorTimeline.js","src/SpineRuntime/Curves.js","src/SpineRuntime/DrawOrderTimeline.js","src/SpineRuntime/Event.js","src/SpineRuntime/EventData.js","src/SpineRuntime/EventTimeline.js","src/SpineRuntime/FfdTimeline.js","src/SpineRuntime/IkConstraint.js","src/SpineRuntime/IkConstraintData.js","src/SpineRuntime/IkConstraintTimeline.js","src/SpineRuntime/MeshAttachment.js","src/SpineRuntime/RegionAttachment.js","src/SpineRuntime/RotateTimeline.js","src/SpineRuntime/ScaleTimeline.js","src/SpineRuntime/ShearTimeline.js","src/SpineRuntime/Skeleton.js","src/SpineRuntime/SkeletonBounds.js","src/SpineRuntime/SkeletonData.js","src/SpineRuntime/SkeletonJsonParser.js","src/SpineRuntime/Skin.js","src/SpineRuntime/Slot.js","src/SpineRuntime/SlotData.js","src/SpineRuntime/TrackEntry.js","src/SpineRuntime/TransformConstraint.js","src/SpineRuntime/TransformConstraintData.js","src/SpineRuntime/TransformConstraintTimeline.js","src/SpineRuntime/TranslateTimeline.js","src/SpineRuntime/WeightedMeshAttachment.js","src/SpineRuntime/index.js","src/SpineUtil/index.js","src/loaders/Loader.js","src/loaders/atlasParser.js","src/loaders/imageLoaderAdapter.js","src/loaders/index.js","src/loaders/syncImageLoaderAdapter.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","PIXI","spine","Spine","SpineRuntime","loaders","./Spine","./SpineRuntime","./loaders","2","spineData","Container","this","skeleton","Skeleton","updateWorldTransform","stateData","AnimationStateData","state","AnimationState","slotContainers","slots","slot","attachment","slotContainer","push","addChild","RegionAttachment","spriteName","rendererObject","name","sprite","createSprite","currentSprite","currentSpriteName","MeshAttachment","mesh","createMesh","currentMesh","currentMeshName","autoUpdate","SlotContainerUpdateTransformV3","pt","parent","worldTransform","wt","lt","localTransform","b","c","d","tx","ty","worldAlpha","alpha","_currentBounds","atlasParser","Bone","yDown","fromAtlas","resourceName","skeletonData","AnimCache","prototype","Object","create","constructor","globalAutoUpdate","defineProperties","get","updateTransform","autoUpdateTransform","set","value","update","dt","apply","drawOrder","children","type","AttachmentType","region","undefined","visible","sprites","transform","_dirtyLocal","TransformStatic","_dirtyParentVersion","_versionLocal","bone","matrix","copy","x","y","Matrix","displayObjectUpdateTransform","blendMode","tint","utils","rgb2hex","g","skinnedmesh","meshName","meshes","computeWorldVertices","vertices","lastTime","Date","now","timeDelta","descriptor","texture","Sprite","scale","scaleX","width","originalWidth","scaleY","height","originalHeight","rotation","degRad","anchor","position","baseTexture","page","Texture","strip","Mesh","Float32Array","uvs","Uint16Array","triangles","DRAW_MODES","TRIANGLES","canvasPadding","../SpineRuntime","../loaders/atlasParser","3","Animation","timelines","duration","time","loop","events","mix","binarySearch","values","target","step","low","high","Math","floor","current","binarySearch1","linearSearch","last","../SpineUtil","4","TrackEntry","data","tracks","onStart","onEnd","onComplete","onEvent","timeScale","delta","previous","previousDelta","mixTime","next","delay","setCurrent","endTime","clearTrack","resetDrawOrder","previousTime","animation","mixDuration","ii","nn","event","count","clearTracks","trackIndex","_expandToIndex","index","entry","getMix","setAnimationByName","animationName","findAnimation","setAnimation","addAnimationByName","addAnimation","hasAnimationByName","getCurrent","./TrackEntry","5","animationToMixTime","defaultMix","setMixByName","fromName","toName","from","to","setMix","key","hasOwnProperty","6","AtlasReader","AtlasPage","AtlasRegion","syncImageLoaderAdapter","Atlas","atlasText","loaderFunction","callback","pages","regions","addSpineAtlas","addTexture","realWidth","realHeight","format","minFilter","magFilter","uWrap","TextureWrap","clampToEdge","vWrap","addTextureHash","textures","stripExtension","indexOf","substr","lastIndexOf","iterateParser","line","reader","readLine","self","trim","readTuple","tuple","parseInt","Format","TextureFilter","direction","readValue","repeat","hasLoaded","console","log","rotate","resolution","frame","Rectangle","splits","pads","offsetX","offsetY","orig","VERSION","frame2","crop","clone","_updateUvs","baseUrl","crossOrigin","texturesLoading","findRegion","dispose","destroy","updateUVs","intensity","luminanceAlpha","rgb565","rgba4444","rgb888","rgba8888","nearest","linear","mipMap","mipMapNearestNearest","mipMapLinearNearest","mipMapNearestLinear","mipMapLinearLinear","mirroredRepeat","../loaders/syncImageLoaderAdapter.js","./AtlasPage","./AtlasReader","./AtlasRegion","7","WeightedMeshAttachment","BoundingBoxAttachment","AtlasAttachmentParser","atlas","newRegionAttachment","skin","path","setUVs","v","u2","v2","regionOffsetX","regionOffsetY","spineOffsetY","regionWidth","regionHeight","regionOriginalWidth","regionOriginalHeight","newMeshAttachment","newWeightedMeshAttachment","newBoundingBoxAttachment","./BoundingBoxAttachment","./MeshAttachment","./RegionAttachment","./WeightedMeshAttachment","8","9","text","lines","split","replace","colon","substring","lastMatch","comma","10","tex","_uvs","x0","y0","x2","y2","warn","pixiOffsetY","11","Curves","AttachmentTimeline","frameCount","curves","frames","attachmentNames","slotIndex","getFrameCount","setFrame","frameIndex","attachmentName","firedEvents","Number","MAX_VALUE","setAttachment","getAttachmentBySlotIndex","./Animation","./Curves","12","boundingbox","weightedmesh","linkedmesh","weightedlinkedmesh","13","boneData","setToSetupPose","rotationIK","shearX","shearY","flipX","flipY","worldSignX","worldSignY","rotationX","rotationY","la","cos","lb","lc","sin","ld","m","signum","pa","pb","pc","pd","inheritRotation","inheritScale","temp","psx","psy","za","zb","zc","zd","worldToLocal","world","dx","dy","invDet","localToWorld","local","localX","localY","getWorldRotationX","atan2","radDeg","getWorldRotationY","getWorldScaleX","sqrt","getWorldScaleY","worldX","worldY","14","BoneData","15","worldVertices","m00","m01","m10","m11","px","py","./AttachmentType","16","ColorTimeline","prevFrameR","prevFrameG","prevFrameB","prevFrameA","frameTime","percent","getCurvePercent","17","setLinear","setStepped","setCurve","cx1","cy1","cx2","cy2","subdiv1","subdiv2","subdiv3","pre1","pre2","pre4","pre5","tmp1x","tmp1y","tmp2x","tmp2y","dfx","dfy","ddfx","ddfy","dddfx","dddfy","start","prevX","prevY","18","DrawOrderTimeline","drawOrders","drawOrderToSetupIndex","19","Event","intValue","floatValue","stringValue","20","EventData","21","EventTimeline","22","FfdTimeline","frameVertices","slotAttachment","applyFFD","vertexCount","attachmentVertices","k","lastVertices","prevVertices","nextVertices","prev","23","IkConstraint","bendDirection","bones","findBone","apply1","apply2","targetX","targetY","parentRotation","child","bendDir","offset1","offset2","sign2","csx","cy","pp","ppm","wx","wy","a1","a2","l1","l2","outer","abs","acos","ta","aa","bb","ll","dd","c0","c1","c2","q","r0","r1","minAngle","minDist","Infinity","minX","minY","maxAngle","maxDist","maxX","maxY","dist","PI","angle","offset","24","IkConstraintData","25","IkConstraintTimeline","ikConstraintIndex","ikConstraint","ikConstraints","prevFrameMix","26","parentMesh","inheritFFD","regionUVs","hullLength","edges","w1","h1","w2","h2","x1","x3","y1","y3","verticesCount","vx","vy","sourceAttachment","setParentMesh","27","updateOffset","regionScaleX","regionScaleY","localX2","localY2","radians","localXCos","localXSin","localYCos","localYSin","localX2Cos","localX2Sin","localY2Cos","localY2Sin","computeVertices","28","RotateTimeline","boneIndex","amount","prevFrameValue","29","ScaleTimeline","prevFrameX","prevFrameY","30","ShearTimeline","31","Slot","slotData","transformConstraints","TransformConstraint","boneCache","updateCache","ikConstraintsCount","transformConstraintsCount","j","setBonesToSetupPose","setSlotsToSetupPose","constraint","rotateMix","translateMix","scaleMix","shearMix","getRootBone","boneName","findBoneIndex","findSlot","slotName","findSlotIndex","setSkinByName","skinName","findSkin","setSkin","newSkin","_attachAll","getAttachment","getAttachmentBySlotName","defaultSkin","findIkConstraint","constraintName","constraints","findTransformConstraint","./Bone","./IkConstraint","./Slot","32","SkeletonBounds","polygonPool","polygons","boundingBoxes","updateAabb","slotCount","boundingBox","polygon","poolCount","splice","aabbCompute","MIN_VALUE","min","max","aabbContainsPoint","aabbIntersectsSegment","aabbIntersectsSkeleton","bounds","containsPoint","polygonContainsPoint","intersectsSegment","prevIndex","inside","vertexY","vertexX","polygonIntersectsSegment","width12","height12","det1","x4","y4","det2","width34","height34","det3","getPolygon","getWidth","getHeight","33","SkeletonData","skins","animations","version","hash","findEvent","eventName","34","LinkedMesh","TransformConstraintData","SlotData","Skin","TranslateTimeline","TransformConstraintTimeline","SkeletonJsonParser","attachmentLoader","AtlasAttachmentLoader","linkedMeshes","readSkeletonData","root","skeletonMap","boneMap","ik","ikMap","ikConstraintData","transformMap","transformData","offsetRotation","offsetScaleX","offsetScaleY","offsetShearY","slotMap","color","toColor","PIXI_BLEND_MODE_MAP","skinMap","slotEntry","readAttachment","addAttachment","size","linkedMesh","eventMap","eventData","readAnimation","map","getFloatArray","getIntArray","weights","boneCount","timelineName","timeline","valueMap","readCurve","timelineScale","ikConstraintName","transformConstraintName","transformConstraint","transformConstraintIndex","ffd","meshMap","isMesh","verticesValue","meshVertices","drawOrderValues","drawOrderMap","offsets","unchanged","originalIndex","unchangedIndex","offsetMap","curve","Array","hexString","colorIndex","list","./AttachmentTimeline","./BoneData","./ColorTimeline","./DrawOrderTimeline","./Event","./EventData","./EventTimeline","./FfdTimeline","./IkConstraintData","./IkConstraintTimeline","./RotateTimeline","./ScaleTimeline","./ShearTimeline","./SkeletonData","./Skin","./SlotData","./TransformConstraintData","./TransformConstraintTimeline","./TranslateTimeline","35","attachments","oldSkin","36","_attachmentTime","setAttachmentTime","getAttachmentTime","slotDatas","37","multiply","BLEND_MODES","MULTIPLY","screen","SCREEN","additive","ADD","normal","NORMAL","38","39","tempVec","bm","tm","bs","ts","by","40","41","shareMix","translate","shear","42","43","regionU2","regionU","regionV2","regionV","weight","skeletonBones","w","44","./AnimationState","./AnimationStateData","./Atlas","./AtlasAttachmentParser","./Skeleton","./SkeletonBounds","./SkeletonJsonParser","./Skin.js","./TransformConstraint","45","46","Loader","addPixiMiddleware","loader","use","./atlasParser","47","Resource","imageLoaderAdapter","resource","isJson","metadataAtlas","metadata","spineAtlas","spineJsonParser","enableCaching","atlasPath","url","atlasOptions","xhrType","XHR_RESPONSE_TYPE","TEXT","spineMetadata","imageOptions","imageMetadata","adapter","add","res","xhr","responseText","./imageLoaderAdapter","48","namePrefix","49","./Loader","./syncImageLoaderAdapter","50","BaseTexture","fromImage"],"mappings":"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","file":"pixi-spine.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * @namespace PIXI.spine\n */\nmodule.exports = PIXI.spine = {\n    Spine:          require('./Spine'),\n    SpineRuntime:   require('./SpineRuntime'),\n    loaders:        require('./loaders')\n};\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/**\n * @namespace PIXI.spine\n */\nmodule.exports = PIXI.spine = {\n    Spine:          require('./Spine'),\n    SpineRuntime:   require('./SpineRuntime'),\n    loaders:        require('./loaders')\n};\n\n},{\"./Spine\":2,\"./SpineRuntime\":44,\"./loaders\":49}],2:[function(require,module,exports){\nvar spine = require('../SpineRuntime');\nvar atlasParser = require('../loaders/atlasParser');\n\n/* Esoteric Software SPINE wrapper for pixi.js */\nspine.Bone.yDown = true;\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * ```js\n * var spineAnimation = new PIXI.Spine(spineData);\n * ```\n *\n * @class\n * @extends Container\n * @memberof PIXI.spine\n * @param spineData {object} The spine data loaded from a spine atlas.\n */\nfunction Spine(spineData)\n{\n    PIXI.Container.call(this);\n\n    if (!spineData)\n    {\n        throw new Error('The spineData param is required.');\n    }\n\n    if ((typeof spineData) === \"string\")\n    {\n        throw new Error('spineData param cant be string. Please use PIXI.spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n    }\n\n    /**\n     * The spineData object\n     *\n     * @member {object}\n     */\n    this.spineData = spineData;\n\n    /**\n     * A spine Skeleton object\n     *\n     * @member {object}\n     */\n    this.skeleton = new spine.Skeleton(spineData);\n    this.skeleton.updateWorldTransform();\n\n    /**\n     * A spine AnimationStateData object created from the spine data passed in the constructor\n     *\n     * @member {object}\n     */\n    this.stateData = new spine.AnimationStateData(spineData);\n\n    /**\n     * A spine AnimationState object created from the spine AnimationStateData object\n     *\n     * @member {object}\n     */\n    this.state = new spine.AnimationState(this.stateData);\n\n    /**\n     * An array of containers\n     *\n     * @member {Container[]}\n     */\n    this.slotContainers = [];\n\n    for (var i = 0, n = this.skeleton.slots.length; i < n; i++)\n    {\n        var slot = this.skeleton.slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = new PIXI.Container();\n        this.slotContainers.push(slotContainer);\n        this.addChild(slotContainer);\n\n        if (attachment instanceof spine.RegionAttachment)\n        {\n            var spriteName = attachment.rendererObject.name;\n            var sprite = this.createSprite(slot, attachment);\n            slot.currentSprite = sprite;\n            slot.currentSpriteName = spriteName;\n            slotContainer.addChild(sprite);\n        }\n        else if (attachment instanceof spine.MeshAttachment)\n        {\n            var mesh = this.createMesh(slot, attachment);\n            slot.currentMesh = mesh;\n            slot.currentMeshName = attachment.name;\n            slotContainer.addChild(mesh);\n        }\n        else\n        {\n            continue;\n        }\n\n    }\n\n    /**\n     * Should the Spine object update its transforms\n     *\n     * @member {boolean}\n     */\n    this.autoUpdate = true;\n}\n\nSpine.fromAtlas = function(resourceName) {\n    var skeletonData = atlasParser.AnimCache[resourceName];\n\n    if (!skeletonData)\n    {\n        throw new Error('Spine data \"' + resourceName + '\" does not exist in the animation cache');\n    }\n\n    return new Spine(skeletonData);\n}\n\nSpine.prototype = Object.create(PIXI.Container.prototype);\nSpine.prototype.constructor = Spine;\nmodule.exports = Spine;\n\nSpine.globalAutoUpdate = true;\n\nObject.defineProperties(Spine.prototype, {\n    /**\n     * If this flag is set to true, the spine animation will be autoupdated every time\n     * the object id drawn. The down side of this approach is that the delta time is\n     * automatically calculated and you could miss out on cool effects like slow motion,\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n     * autoupdate enabled but are harder to achieve.\n     *\n     * @member {boolean}\n     * @memberof Spine#\n     * @default true\n     */\n    autoUpdate: {\n        get: function ()\n        {\n            return (this.updateTransform === Spine.prototype.autoUpdateTransform);\n        },\n\n        set: function (value)\n        {\n            this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\n        }\n    }\n});\n\n/**\n * Update the spine skeleton and its animations by delta time (dt)\n *\n * @param dt {number} Delta time. Time by which the animation should be updated\n */\nSpine.prototype.update = function (dt)\n{\n    this.state.update(dt);\n    this.state.apply(this.skeleton);\n    this.skeleton.updateWorldTransform();\n\n    var drawOrder = this.skeleton.drawOrder;\n    var slots = this.skeleton.slots;\n\n    for (var i = 0, n = drawOrder.length; i < n; i++)\n    {\n        this.children[i] = this.slotContainers[drawOrder[i]];\n    }\n\n    for (i = 0, n = slots.length; i < n; i++)\n    {\n        var slot = slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = this.slotContainers[i];\n\n        if (!attachment)\n        {\n            slotContainer.visible = false;\n            continue;\n        }\n\n        var type = attachment.type;\n        if (type === spine.AttachmentType.region)\n        {\n            if (attachment.rendererObject)\n            {\n                if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.rendererObject.name)\n                {\n                    var spriteName = attachment.rendererObject.name;\n                    if (slot.currentSprite !== undefined)\n                    {\n                        slot.currentSprite.visible = false;\n                    }\n                    slot.sprites = slot.sprites || {};\n                    if (slot.sprites[spriteName] !== undefined)\n                    {\n                        slot.sprites[spriteName].visible = true;\n                    }\n                    else\n                    {\n                        var sprite = this.createSprite(slot, attachment);\n                        slotContainer.addChild(sprite);\n                    }\n                    slot.currentSprite = slot.sprites[spriteName];\n                    slot.currentSpriteName = spriteName;\n                }\n            }\n\n            if (slotContainer.transform ) {\n                //PIXI v4.0\n                if (!slotContainer.transform._dirtyLocal) {\n                    slotContainer.transform = new PIXI.TransformStatic();\n                }\n                var transform = slotContainer.transform;\n                var lt = transform.localTransform;\n                transform._dirtyParentVersion = -1;\n                transform._dirtyLocal = 1;\n                transform._versionLocal = 1;\n                slot.bone.matrix.copy(lt);\n                lt.tx += slot.bone.skeleton.x;\n                lt.ty += slot.bone.skeleton.y;\n            } else {\n                //PIXI v3\n                var lt = slotContainer.localTransform || new PIXI.Matrix();\n                slot.bone.matrix.copy(lt);\n                lt.tx += slot.bone.skeleton.x;\n                lt.ty += slot.bone.skeleton.y;\n                slotContainer.localTransform = lt;\n                slotContainer.displayObjectUpdateTransform = SlotContainerUpdateTransformV3;\n            }\n\n            slot.currentSprite.blendMode = slot.blendMode;\n            slot.currentSprite.tint = PIXI.utils.rgb2hex([slot.r,slot.g,slot.b]);\n        }\n        else if (type === spine.AttachmentType.skinnedmesh || type === spine.AttachmentType.mesh)\n        {\n            if (!slot.currentMeshName || slot.currentMeshName !== attachment.name)\n            {\n                var meshName = attachment.name;\n                if (slot.currentMesh !== undefined)\n                {\n                    slot.currentMesh.visible = false;\n                }\n\n                slot.meshes = slot.meshes || {};\n\n                if (slot.meshes[meshName] !== undefined)\n                {\n                    slot.meshes[meshName].visible = true;\n                }\n                else\n                {\n                    var mesh = this.createMesh(slot, attachment);\n                    slotContainer.addChild(mesh);\n                }\n\n                slot.currentMesh = slot.meshes[meshName];\n                slot.currentMeshName = meshName;\n            }\n            attachment.computeWorldVertices(slot.bone.skeleton.x, slot.bone.skeleton.y, slot, slot.currentMesh.vertices);\n        }\n        else\n        {\n            slotContainer.visible = false;\n            continue;\n        }\n        slotContainer.visible = true;\n\n        slotContainer.alpha = slot.a;\n    }\n};\n\n/**\n * When autoupdate is set to yes this function is used as pixi's updateTransform function\n *\n * @private\n */\nSpine.prototype.autoUpdateTransform = function ()\n{\n    if (Spine.globalAutoUpdate) {\n        this.lastTime = this.lastTime || Date.now();\n        var timeDelta = (Date.now() - this.lastTime) * 0.001;\n        this.lastTime = Date.now();\n        this.update(timeDelta);\n    } else {\n        this.lastTime = 0;\n    }\n\n    PIXI.Container.prototype.updateTransform.call(this);\n};\n\n/**\n * Create a new sprite to be used with spine.RegionAttachment\n *\n * @param slot {spine.Slot} The slot to which the attachment is parented\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n * @private\n */\nSpine.prototype.createSprite = function (slot, attachment)\n{\n    var descriptor = attachment.rendererObject;\n    var texture = descriptor.texture;\n    var sprite = new PIXI.Sprite(texture);\n    sprite.scale.x = attachment.scaleX * attachment.width / descriptor.originalWidth;\n    sprite.scale.y = - attachment.scaleY * attachment.height / descriptor.originalHeight;\n    sprite.rotation = attachment.rotation * spine.degRad;\n    sprite.anchor.x = 0.5;\n    sprite.anchor.y = 0.5;\n    sprite.position.x = attachment.x;\n    sprite.position.y = attachment.y;\n    sprite.alpha = attachment.a;\n\n    slot.sprites = slot.sprites || {};\n    slot.sprites[descriptor.name] = sprite;\n    return sprite;\n};\n\n/**\n * Creates a Strip from the spine data\n * @param slot {spine.Slot} The slot to which the attachment is parented\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n * @private\n */\nSpine.prototype.createMesh = function (slot, attachment)\n{\n    var descriptor = attachment.rendererObject;\n    var baseTexture = descriptor.page.rendererObject;\n    var texture = new PIXI.Texture(baseTexture);\n\n    var strip = new PIXI.mesh.Mesh(\n        texture,\n        new Float32Array(attachment.uvs.length),\n        new Float32Array(attachment.uvs),\n        new Uint16Array(attachment.triangles),\n        PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\n\n    strip.canvasPadding = 1.5;\n\n    strip.alpha = attachment.a;\n\n    slot.meshes = slot.meshes || {};\n    slot.meshes[attachment.name] = strip;\n\n    return strip;\n};\n\nfunction SlotContainerUpdateTransformV3()\n{\n    var pt = this.parent.worldTransform;\n    var wt = this.worldTransform;\n    var lt = this.localTransform;\n    wt.a  = lt.a  * pt.a + lt.b  * pt.c;\n    wt.b  = lt.a  * pt.b + lt.b  * pt.d;\n    wt.c  = lt.c  * pt.a + lt.d  * pt.c;\n    wt.d  = lt.c  * pt.b + lt.d  * pt.d;\n    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    this._currentBounds = null;\n};\n\n},{\"../SpineRuntime\":44,\"../loaders/atlasParser\":47}],3:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.Animation = function (name, timelines, duration)\n{\n    this.name = name;\n    this.timelines = timelines;\n    this.duration = duration;\n};\nspine.Animation.prototype = {\n    apply: function (skeleton, lastTime, time, loop, events)\n    {\n        if (loop && this.duration != 0)\n        {\n            time %= this.duration;\n            lastTime %= this.duration;\n        }\n        var timelines = this.timelines;\n        for (var i = 0, n = timelines.length; i < n; i++)\n            timelines[i].apply(skeleton, lastTime, time, events, 1);\n    },\n    mix: function (skeleton, lastTime, time, loop, events, alpha)\n    {\n        if (loop && this.duration != 0)\n        {\n            time %= this.duration;\n            lastTime %= this.duration;\n        }\n        var timelines = this.timelines;\n        for (var i = 0, n = timelines.length; i < n; i++)\n            timelines[i].apply(skeleton, lastTime, time, events, alpha);\n    }\n};\nspine.Animation.binarySearch = function (values, target, step)\n{\n    var low = 0;\n    var high = Math.floor(values.length / step) - 2;\n    if (!high) return step;\n    var current = high >>> 1;\n    while (true)\n    {\n        if (values[(current + 1) * step] <= target)\n            low = current + 1;\n        else\n            high = current;\n        if (low == high) return (low + 1) * step;\n        current = (low + high) >>> 1;\n    }\n};\nspine.Animation.binarySearch1 = function (values, target)\n{\n    var low = 0;\n    var high = values.length - 2;\n    if (!high) return 1;\n    var current = high >>> 1;\n    while (true)\n    {\n        if (values[current + 1] <= target)\n            low = current + 1;\n        else\n            high = current;\n        if (low == high) return low + 1;\n        current = (low + high) >>> 1;\n    }\n};\nspine.Animation.linearSearch = function (values, target, step)\n{\n    for (var i = 0, last = values.length - step; i <= last; i += step)\n        if (values[i] > target) return i;\n    return -1;\n};\nmodule.exports = spine.Animation;\n\n},{\"../SpineUtil\":45}],4:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.TrackEntry = require('./TrackEntry');\nspine.AnimationState = function (stateData)\n{\n    this.data = stateData;\n    this.tracks = [];\n    this.events = [];\n};\nspine.AnimationState.prototype = {\n    onStart: null,\n    onEnd: null,\n    onComplete: null,\n    onEvent: null,\n    timeScale: 1,\n    update: function (delta)\n    {\n        delta *= this.timeScale;\n        for (var i = 0; i < this.tracks.length; i++)\n        {\n            var current = this.tracks[i];\n            if (!current) continue;\n\n            current.time += delta * current.timeScale;\n            if (current.previous)\n            {\n                var previousDelta = delta * current.previous.timeScale;\n                current.previous.time += previousDelta;\n                current.mixTime += previousDelta;\n            }\n\n            var next = current.next;\n            if (next)\n            {\n                next.time = current.lastTime - next.delay;\n                if (next.time >= 0) this.setCurrent(i, next);\n            } else {\n                // End non-looping animation when it reaches its end time and there is no next entry.\n                if (!current.loop && current.lastTime >= current.endTime) this.clearTrack(i);\n            }\n        }\n    },\n    apply: function (skeleton)\n    {\n        skeleton.resetDrawOrder();\n\n        for (var i = 0; i < this.tracks.length; i++)\n        {\n            var current = this.tracks[i];\n            if (!current) continue;\n\n            this.events.length = 0;\n\n            var time = current.time;\n            var lastTime = current.lastTime;\n            var endTime = current.endTime;\n            var loop = current.loop;\n            if (!loop && time > endTime) time = endTime;\n\n            var previous = current.previous;\n            if (!previous)\n            {\n                if (current.mix == 1)\n                    current.animation.apply(skeleton, current.lastTime, time, loop, this.events);\n                else\n                    current.animation.mix(skeleton, current.lastTime, time, loop, this.events, current.mix);\n            } else {\n                var previousTime = previous.time;\n                if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;\n                previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);\n\n                var alpha = current.mixTime / current.mixDuration * current.mix;\n                if (alpha >= 1)\n                {\n                    alpha = 1;\n                    current.previous = null;\n                }\n                current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha);\n            }\n\n            for (var ii = 0, nn = this.events.length; ii < nn; ii++)\n            {\n                var event = this.events[ii];\n                if (current.onEvent) current.onEvent(i, event);\n                if (this.onEvent) this.onEvent(i, event);\n            }\n\n            // Check if completed the animation or a loop iteration.\n            if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime))\n            {\n                var count = Math.floor(time / endTime);\n                if (current.onComplete) current.onComplete(i, count);\n                if (this.onComplete) this.onComplete(i, count);\n            }\n\n            current.lastTime = current.time;\n        }\n    },\n    clearTracks: function ()\n    {\n        for (var i = 0, n = this.tracks.length; i < n; i++)\n            this.clearTrack(i);\n        this.tracks.length = 0;\n    },\n    clearTrack: function (trackIndex)\n    {\n        if (trackIndex >= this.tracks.length) return;\n        var current = this.tracks[trackIndex];\n        if (!current) return;\n\n        if (current.onEnd) current.onEnd(trackIndex);\n        if (this.onEnd) this.onEnd(trackIndex);\n\n        this.tracks[trackIndex] = null;\n    },\n    _expandToIndex: function (index)\n    {\n        if (index < this.tracks.length) return this.tracks[index];\n        while (index >= this.tracks.length)\n            this.tracks.push(null);\n        return null;\n    },\n    setCurrent: function (index, entry)\n    {\n        var current = this._expandToIndex(index);\n        if (current)\n        {\n            var previous = current.previous;\n            current.previous = null;\n\n            if (current.onEnd) current.onEnd(index);\n            if (this.onEnd) this.onEnd(index);\n\n            entry.mixDuration = this.data.getMix(current.animation, entry.animation);\n            if (entry.mixDuration > 0)\n            {\n                entry.mixTime = 0;\n                // If a mix is in progress, mix from the closest animation.\n                if (previous && current.mixTime / current.mixDuration < 0.5)\n                    entry.previous = previous;\n                else\n                    entry.previous = current;\n            }\n        }\n\n        this.tracks[index] = entry;\n\n        if (entry.onStart) entry.onStart(index);\n        if (this.onStart) this.onStart(index);\n    },\n    setAnimationByName: function (trackIndex, animationName, loop)\n    {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        if (!animation) throw \"Animation not found: \" + animationName;\n        return this.setAnimation(trackIndex, animation, loop);\n    },\n    /** Set the current animation. Any queued animations are cleared. */\n    setAnimation: function (trackIndex, animation, loop)\n    {\n        var entry = new spine.TrackEntry();\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.endTime = animation.duration;\n        this.setCurrent(trackIndex, entry);\n        return entry;\n    },\n    addAnimationByName: function (trackIndex, animationName, loop, delay)\n    {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        if (!animation) throw \"Animation not found: \" + animationName;\n        return this.addAnimation(trackIndex, animation, loop, delay);\n    },\n    /** Adds an animation to be played delay seconds after the current or last queued animation.\n     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\n    addAnimation: function (trackIndex, animation, loop, delay)\n    {\n        var entry = new spine.TrackEntry();\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.endTime = animation.duration;\n\n        var last = this._expandToIndex(trackIndex);\n        if (last)\n        {\n            while (last.next)\n                last = last.next;\n            last.next = entry;\n        } else\n            this.tracks[trackIndex] = entry;\n\n        if (delay <= 0)\n        {\n            if (last)\n                delay += last.endTime - this.data.getMix(last.animation, animation);\n            else\n                delay = 0;\n        }\n        entry.delay = delay;\n\n        return entry;\n    },\n    /**\n     * Returns true if animation exists in skeleton data\n     * @param animationName\n     * @returns {boolean}\n     */\n    hasAnimationByName: function (animationName)\n    {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        return animation !== null;\n    },\n    /** May be null. */\n    getCurrent: function (trackIndex)\n    {\n        if (trackIndex >= this.tracks.length) return null;\n        return this.tracks[trackIndex];\n    }\n};\nmodule.exports = spine.AnimationState;\n\n\n},{\"../SpineUtil\":45,\"./TrackEntry\":38}],5:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.AnimationStateData = function (skeletonData)\n{\n    this.skeletonData = skeletonData;\n    this.animationToMixTime = {};\n};\nspine.AnimationStateData.prototype = {\n    defaultMix: 0,\n    setMixByName: function (fromName, toName, duration)\n    {\n        var from = this.skeletonData.findAnimation(fromName);\n        if (!from) throw \"Animation not found: \" + fromName;\n        var to = this.skeletonData.findAnimation(toName);\n        if (!to) throw \"Animation not found: \" + toName;\n        this.setMix(from, to, duration);\n    },\n    setMix: function (from, to, duration)\n    {\n        this.animationToMixTime[from.name + \":\" + to.name] = duration;\n    },\n    getMix: function (from, to)\n    {\n        var key = from.name + \":\" + to.name;\n        return this.animationToMixTime.hasOwnProperty(key) ? this.animationToMixTime[key] : this.defaultMix;\n    }\n};\nmodule.exports = spine.AnimationStateData;\n\n\n},{\"../SpineUtil\":45}],6:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.AtlasReader = require('./AtlasReader');\nspine.AtlasPage = require('./AtlasPage');\nspine.AtlasRegion = require('./AtlasRegion');\nvar syncImageLoaderAdapter = require('../loaders/syncImageLoaderAdapter.js')\n\nspine.Atlas = function(atlasText, loaderFunction, callback) {\n    this.pages = [];\n    this.regions = [];\n    if (typeof atlasText === \"string\") {\n        this.addSpineAtlas.call(this, atlasText, loaderFunction, callback);\n    }\n};\n\nspine.Atlas.prototype = {\n    addTexture: function(name, texture) {\n        var pages = this.pages;\n        var page = null;\n        for (var i=0;i<pages.length;i++) {\n            if (pages[i].rendererObject === texture.baseTexture) {\n                page = pages[i];\n                break;\n            }\n        }\n        if (page === null) {\n            page = new spine.AtlasPage();\n            page.name = 'texturePage';\n            var baseTexture = texture.baseTexture;\n            page.width = baseTexture.realWidth;\n            page.height = baseTexture.realHeight;\n            page.rendererObject = baseTexture;\n            //those fields are not relevant in Pixi\n            page.format = 'RGBA8888';\n            page.minFilter = page.magFilter = \"Nearest\";\n            page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\n            page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\n            pages.push(page);\n        }\n        var region = new spine.AtlasRegion();\n        region.name = name;\n        region.page = page;\n        region.texture = texture;\n        region.index = -1;\n        this.regions.push(region);\n        return region;\n    },\n    addTextureHash: function(textures, stripExtension) {\n        for (var key in textures) {\n            if (textures.hasOwnProperty(key)) {\n                this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\n            }\n        }\n    },\n    addSpineAtlas: function (atlasText, loaderFunction, callback)\n    {\n        //TODO: remove this legacy later\n        if (typeof loaderFunction !== \"function\") {\n            //old syntax\n            var baseUrl = loaderFunction;\n            var crossOrigin = callback;\n            loaderFunction = syncImageLoaderAdapter(baseUrl, crossOrigin);\n            callback = null;\n        }\n\n        this.texturesLoading = 0;\n\n        var self = this;\n\n        var reader = new spine.AtlasReader(atlasText);\n        var tuple = [];\n        tuple.length = 4;\n        var page = null;\n\n        iterateParser();\n\n        function iterateParser() {\n            while (true) {\n                var line = reader.readLine();\n                if (line === null) {\n                    return callback && callback(self);\n                }\n                line = reader.trim(line);\n                if (!line.length)\n                    page = null;\n                else if (!page) {\n                    page = new spine.AtlasPage();\n                    page.name = line;\n\n                    if (reader.readTuple(tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.\n                        page.width = parseInt(tuple[0]);\n                        page.height = parseInt(tuple[1]);\n                        reader.readTuple(tuple);\n                    } else {\n                        //old format, detect width and height by texture\n                    }\n                    page.format = spine.Atlas.Format[tuple[0]];\n\n                    reader.readTuple(tuple);\n                    page.minFilter = spine.Atlas.TextureFilter[tuple[0]];\n                    page.magFilter = spine.Atlas.TextureFilter[tuple[1]];\n\n                    var direction = reader.readValue();\n                    page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\n                    page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\n                    if (direction == \"x\")\n                        page.uWrap = spine.Atlas.TextureWrap.repeat;\n                    else if (direction == \"y\")\n                        page.vWrap = spine.Atlas.TextureWrap.repeat;\n                    else if (direction == \"xy\")\n                        page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;\n\n                    // @ivanpopelyshev: I so want to use generators and \"yield()\" here, or at least promises\n                    loaderFunction(line, function (texture) {\n                        page.rendererObject = texture;\n                        if (!texture.hasLoaded) {\n                            texture.width = page.width;\n                            texture.height = page.height;\n                        }\n                        self.pages.push(page);\n                        if (!page.width || !page.height) {\n                            page.width = texture.realWidth;\n                            page.height = texture.realHeight;\n                            if (!page.width || !page.height) {\n                                console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\n                            }\n                        }\n                        iterateParser();\n                    });\n                    break;\n                } else {\n                    var region = new spine.AtlasRegion();\n                    region.name = line;\n                    region.page = page;\n\n                    var rotate = reader.readValue() === \"true\" ? 6 : 0;\n\n                    reader.readTuple(tuple);\n                    var x = parseInt(tuple[0]);\n                    var y = parseInt(tuple[1]);\n\n                    reader.readTuple(tuple);\n                    var width = parseInt(tuple[0]);\n                    var height = parseInt(tuple[1]);\n\n                    var resolution = page.rendererObject.resolution;\n                    x /= resolution;\n                    y /= resolution;\n                    width /= resolution;\n                    height /= resolution;\n\n                    var frame = new PIXI.Rectangle(x, y, rotate ? height : width, rotate ? width : height);\n\n                    if (reader.readTuple(tuple) == 4) { // split is optional\n                        region.splits = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\n\n                        if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\n                            region.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\n\n                            reader.readTuple(tuple);\n                        }\n                    }\n\n                    var originalWidth = parseInt(tuple[0]) / resolution;\n                    var originalHeight = parseInt(tuple[1]) / resolution;\n                    reader.readTuple(tuple);\n                    var offsetX = parseInt(tuple[0]) / resolution;\n                    var offsetY = parseInt(tuple[1]) / resolution;\n\n                    var orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\n                    var trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\n\n                    //TODO: pixiv3 uses different frame/crop/trim\n\n                    if (PIXI.VERSION[0] == '4') {\n                        // pixi v4.0.0\n                        region.texture = new PIXI.Texture(region.page.rendererObject, frame, orig, trim, rotate);\n                    } else {\n                        // pixi v3.0.11\n                        var frame2 = new PIXI.Rectangle(x, y, width, height);\n                        var crop = frame2.clone();\n                        trim.width = originalWidth;\n                        trim.height = originalHeight;\n                        region.texture = new PIXI.Texture(region.page.rendererObject, frame2, crop, trim, rotate);\n                    }\n\n                    region.index = parseInt(reader.readValue());\n                    region.texture._updateUvs();\n\n                    self.regions.push(region);\n                }\n            }\n        }\n    },\n    findRegion: function (name)\n    {\n        var regions = this.regions;\n        for (var i = 0, n = regions.length; i < n; i++)\n            if (regions[i].name == name) return regions[i];\n        return null;\n    },\n    dispose: function ()\n    {\n        var pages = this.pages;\n        for (var i = 0, n = pages.length; i < n; i++)\n            pages[i].rendererObject.destroy(true);\n    },\n    updateUVs: function (page)\n    {\n        var regions = this.regions;\n        for (var i = 0, n = regions.length; i < n; i++)\n        {\n            var region = regions[i];\n            if (region.page != page) continue;\n            region.texture._updateUvs();\n        }\n    }\n};\n\nspine.Atlas.Format = {\n    alpha: 0,\n    intensity: 1,\n    luminanceAlpha: 2,\n    rgb565: 3,\n    rgba4444: 4,\n    rgb888: 5,\n    rgba8888: 6\n};\n\nspine.Atlas.TextureFilter = {\n    nearest: 0,\n    linear: 1,\n    mipMap: 2,\n    mipMapNearestNearest: 3,\n    mipMapLinearNearest: 4,\n    mipMapNearestLinear: 5,\n    mipMapLinearLinear: 6\n};\n\nspine.Atlas.TextureWrap = {\n    mirroredRepeat: 0,\n    clampToEdge: 1,\n    repeat: 2\n};\nmodule.exports = spine.Atlas;\n\n},{\"../SpineUtil\":45,\"../loaders/syncImageLoaderAdapter.js\":50,\"./AtlasPage\":8,\"./AtlasReader\":9,\"./AtlasRegion\":10}],7:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.RegionAttachment = require('./RegionAttachment');\nspine.MeshAttachment = require('./MeshAttachment');\nspine.WeightedMeshAttachment = require('./WeightedMeshAttachment');\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\nspine.AtlasAttachmentParser = function (atlas)\n{\n    this.atlas = atlas;\n};\nspine.AtlasAttachmentParser.prototype = {\n    newRegionAttachment: function (skin, name, path)\n    {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\";\n        var attachment = new spine.RegionAttachment(name);\n        attachment.rendererObject = region;\n        attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);\n        attachment.regionOffsetX = region.offsetX;\n        attachment.regionOffsetY = region.spineOffsetY;\n        attachment.regionWidth = region.width;\n        attachment.regionHeight = region.height;\n        attachment.regionOriginalWidth = region.originalWidth;\n        attachment.regionOriginalHeight = region.originalHeight;\n        return attachment;\n    },\n    newMeshAttachment: function (skin, name, path)\n    {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\";\n        var attachment = new spine.MeshAttachment(name);\n        attachment.rendererObject = region;\n        // region.texture.on('update', spine.MeshAttachment.prototype.updateUVs.bind(attachment));\n        return attachment;\n    },\n    newWeightedMeshAttachment: function (skin, name, path)\n    {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (skinned mesh attachment: \" + name + \")\";\n        var attachment = new spine.WeightedMeshAttachment(name);\n        attachment.rendererObject = region;\n        // region.texture.on('update', spine.WeightedMeshAttachment.prototype.updateUVs.bind(attachment));\n        return attachment;\n    },\n    newBoundingBoxAttachment: function (skin, name)\n    {\n        return new spine.BoundingBoxAttachment(name);\n    }\n};\nmodule.exports = spine.AtlasAttachmentParser;\n\n\n},{\"../SpineUtil\":45,\"./BoundingBoxAttachment\":15,\"./MeshAttachment\":26,\"./RegionAttachment\":27,\"./WeightedMeshAttachment\":43}],8:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.AtlasPage = function ()\n{};\nspine.AtlasPage.prototype = {\n    name: null,\n    format: null,\n    minFilter: null,\n    magFilter: null,\n    uWrap: null,\n    vWrap: null,\n    rendererObject: null,\n    width: 0,\n    height: 0\n};\nmodule.exports = spine.AtlasPage;\n\n\n},{\"../SpineUtil\":45}],9:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.AtlasReader = function (text)\n{\n    this.lines = text.split(/\\r\\n|\\r|\\n/);\n};\nspine.AtlasReader.prototype = {\n    index: 0,\n    trim: function (value)\n    {\n        return value.replace(/^\\s+|\\s+$/g, \"\");\n    },\n    readLine: function ()\n    {\n        if (this.index >= this.lines.length) return null;\n        return this.lines[this.index++];\n    },\n    readValue: function ()\n    {\n        var line = this.readLine();\n        var colon = line.indexOf(\":\");\n        if (colon == -1) throw \"Invalid line: \" + line;\n        return this.trim(line.substring(colon + 1));\n    },\n    /** Returns the number of tuple values read (1, 2 or 4). */\n    readTuple: function (tuple)\n    {\n        var line = this.readLine();\n        var colon = line.indexOf(\":\");\n        if (colon == -1) throw \"Invalid line: \" + line;\n        var i = 0, lastMatch = colon + 1;\n        for (; i < 3; i++)\n        {\n            var comma = line.indexOf(\",\", lastMatch);\n            if (comma == -1) break;\n            tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));\n            lastMatch = comma + 1;\n        }\n        tuple[i] = this.trim(line.substring(lastMatch));\n        return i + 1;\n    }\n};\nmodule.exports = spine.AtlasReader;\n\n\n},{\"../SpineUtil\":45}],10:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.AtlasRegion = function ()\n{};\nspine.AtlasRegion.prototype = {\n    name: null,\n    /**\n     * @member {PIXI.Texture}\n     */\n    texture: null,\n\n    /**\n     * @member {PIXI.spine.Spine.AtlasPage}\n     */\n    page: null,\n    index: 0,\n    splits: null,\n    pads: null\n};\n\nObject.defineProperties(spine.AtlasRegion.prototype, {\n    x: {\n        get: function() {\n            return this.texture.frame.x;\n        }\n    },\n    y: {\n        get: function() {\n            return this.texture.frame.y;\n        }\n    },\n    width: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                return tex.crop.width;\n            }\n            if (tex.trim) {\n                return tex.trim.width;\n            }\n            return tex.orig.width;\n        }\n    },\n    height: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                return tex.crop.height;\n            }\n            if (tex.trim) {\n                return tex.trim.height;\n            }\n            return tex.orig.height;\n        }\n    },\n    u: {\n        get: function() {\n            return this.texture._uvs.x0;\n        }\n    },\n    v: {\n        get: function() {\n            return this.texture._uvs.y0;\n        }\n    },\n    u2: {\n        get: function() {\n            return this.texture._uvs.x2;\n        }\n    },\n    v2: {\n        get: function() {\n            return this.texture._uvs.y2;\n        }\n    },\n    rotate: {\n        get: function() {\n            return !!this.texture.rotate;\n        }\n    },\n    offsetX: {\n        get: function() {\n            var tex = this.texture;\n            return tex.trim ? tex.trim.x : 0;\n        }\n    },\n    offsetY: {\n        get: function() {\n            console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\n            return this.spineOffsetY;\n        }\n    },\n    pixiOffsetY: {\n        get: function() {\n            var tex = this.texture;\n            return tex.trim ? tex.trim.y : 0;\n        }\n    },\n    spineOffsetY: {\n        get: function() {\n            var tex = this.texture;\n            return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\n        }\n    },\n    originalWidth: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                if (tex.trim) {\n                    return tex.trim.width;\n                }\n                return tex.crop.width;\n            }\n            return tex.orig.width;\n        }\n    },\n    originalHeight: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                if (tex.trim) {\n                    return tex.trim.height;\n                }\n                return tex.crop.height;\n            }\n            return tex.orig.height;\n        }\n    }\n});\n\nmodule.exports = spine.AtlasRegion;\n\n\n},{\"../SpineUtil\":45}],11:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.Curves = require('./Curves');\nspine.Animation = require('./Animation');\nspine.AttachmentTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, ...\n    this.frames.length = frameCount;\n    this.attachmentNames = [];\n    this.attachmentNames.length = frameCount;\n};\nspine.AttachmentTimeline.prototype = {\n    slotIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length;\n    },\n    setFrame: function (frameIndex, time, attachmentName)\n    {\n        this.frames[frameIndex] = time;\n        this.attachmentNames[frameIndex] = attachmentName;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0])\n        {\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\n            return;\n        } else if (lastTime > time) //\n            lastTime = -1;\n\n        var frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : spine.Animation.binarySearch1(frames, time) - 1;\n        if (frames[frameIndex] < lastTime) return;\n\n        var attachmentName = this.attachmentNames[frameIndex];\n        skeleton.slots[this.slotIndex].setAttachment(\n            !attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));\n    }\n};\nmodule.exports = spine.AttachmentTimeline;\n\n\n},{\"../SpineUtil\":45,\"./Animation\":3,\"./Curves\":17}],12:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.AttachmentType = {\n    region: 0,\n    boundingbox: 1,\n    mesh: 2,\n    weightedmesh : 3,\n    skinnedmesh: 3,\n    linkedmesh: 4,\n    weightedlinkedmesh: 5\n};\nmodule.exports = spine.AttachmentType;\n\n\n},{\"../SpineUtil\":45}],13:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.Bone = function (boneData, skeleton, parent)\n{\n    this.data = boneData;\n    this.skeleton = skeleton;\n    this.parent = parent;\n    this.matrix = new PIXI.Matrix();\n    this.setToSetupPose();\n};\nspine.Bone.yDown = false;\nspine.Bone.prototype = {\n    x: 0, y: 0,\n    rotation: 0, rotationIK: 0,\n    scaleX: 1, scaleY: 1,\n    shearX: 0, shearY: 0,\n    flipX: false, flipY: false,\n\n    worldSignX: 1, worldSignY: 1,\n    update: function() {\n        this.rotationIK = this.rotation;\n        this.updateWorldTransform();\n    },\n    updateWorldTransform: function() {\n        var rotation = this.rotationIK;\n        var scaleX = this.scaleX;\n        var scaleY = this.scaleY;\n        var x = this.x;\n        var y = this.y;\n        var rotationX = rotation + this.shearX;\n        var rotationY = rotation + 90 + this.shearY;\n\n        var la = Math.cos(rotationX * spine.degRad) * scaleX, lb = Math.cos(rotationY * spine.degRad) * scaleY,\n            lc = Math.sin(rotationX * spine.degRad) * scaleX, ld = Math.sin(rotationY * spine.degRad) * scaleY;\n        var parent = this.parent;\n        var m = this.matrix;\n        var skeleton = this.skeleton;\n        if (!parent) { // Root bone.\n            if (skeleton.flipX) {\n                x = -x;\n                la = -la;\n                lb = -lb;\n            }\n            if (skeleton.flipY !== spine.Bone.yDown) {\n                y = -y;\n                lc = -lc;\n                ld = -ld;\n            }\n            m.a = la;\n            m.c = lb;\n            m.b = lc;\n            m.d = ld;\n            m.tx = x;\n            m.ty = y;\n            this.worldSignX = spine.signum(scaleX);\n            this.worldSignY = spine.signum(scaleY);\n            return;\n        }\n\n\n        var pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\n        m.tx = pa * x + pb * y + parent.matrix.tx;\n        m.ty = pc * x + pd * y + parent.matrix.ty;\n        this.worldSignX = parent.worldSignX * spine.signum(scaleX);\n        this.worldSignY = parent.worldSignY * spine.signum(scaleY);\n        var data = this.data;\n\n        if (data.inheritRotation && data.inheritScale) {\n            m.a = pa * la + pb * lc;\n            m.c = pa * lb + pb * ld;\n            m.b = pc * la + pd * lc;\n            m.d = pc * lb + pd * ld;\n        } else {\n            if (data.inheritRotation) { // No scale inheritance.\n                pa = 1;\n                pb = 0;\n                pc = 0;\n                pd = 1;\n                do {\n                    cos = Math.cos(parent.rotationIK * spine.degRad);\n                    sin = Math.sin(parent.rotationIK * spine.degRad);\n                    var temp = pa * cos + pb * sin;\n                    pb = pa * -sin + pb * cos;\n                    pa = temp;\n                    temp = pc * cos + pd * sin;\n                    pd = pc * -sin + pd * cos;\n                    pc = temp;\n\n                    if (!parent.data.inheritRotation) break;\n                    parent = parent.parent;\n                } while (parent != null);\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n            } else if (data.inheritScale) { // No rotation inheritance.\n                pa = 1;\n                pb = 0;\n                pc = 0;\n                pd = 1;\n                do {\n                    var r = parent.rotationIK;\n                    cos = Math.cos(r * spine.degRad);\n                    sin = Math.sin(r * spine.degRad);\n                    var psx = parent.scaleX, psy = parent.scaleY;\n                    var za = cos * psx, zb = -sin * psy, zc = sin * psx, zd = cos * psy;\n                    temp = pa * za + pb * zc;\n                    pb = pa * zb + pb * zd;\n                    pa = temp;\n                    temp = pc * za + pd * zc;\n                    pd = pc * zb + pd * zd;\n                    pc = temp;\n\n                    if (psx < 0) {\n                        r = -r;\n                    } else {\n                        sin = -sin;\n                    }\n                    temp = pa * cos + pb * sin;\n                    pb = pa * -sin + pb * cos;\n                    pa = temp;\n                    temp = pc * cos + pd * sin;\n                    pd = pc * -sin + pd * cos;\n                    pc = temp;\n\n                    if (!parent.data.inheritScale) break;\n                    parent = parent.parent;\n                } while (parent != null);\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n            } else {\n                m.a = la;\n                m.c = lb;\n                m.b = lc;\n                m.d = ld;\n            }\n            if (skeleton.flipX) {\n                m.a = -m.a;\n                m.c = -m.c;\n            }\n            if (skeleton.flipY !== spine.Bone.yDown) {\n                m.b = -m.b;\n                m.d = -m.d;\n            }\n        }\n    },\n\n    setToSetupPose: function ()\n    {\n        var data = this.data;\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.rotationIK = this.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n        this.shearX = data.shearX;\n        this.shearY = data.shearY;\n    },\n    worldToLocal: function (world)\n    {\n        var m = this.matrix;\n        var dx = world[0] - m.tx, dy = m.ty;\n        var invDet = 1 / (m.a * m.d - m.b * m.c);\n        //Yep, its a bug in original spine. I hope they'll fix it: https://github.com/EsotericSoftware/spine-runtimes/issues/544\n        world[0] = dx * m.a * invDet - dy * m.c * invDet;\n        world[1] = dy * m.d * invDet - dx * m.b * invDet;\n    },\n    localToWorld: function (local)\n    {\n        var localX = local[0], localY = local[1];\n        var m = this.matrix;\n        local[0] = localX * m.a + localY * m.c + m.tx;\n        local[1] = localX * m.b + localY * m.d + m.ty;\n    },\n    getWorldRotationX: function() {\n        return Math.atan2(this.matrix.b, this.matrix.a) * spine.radDeg;\n\n    },\n    getWorldRotationY: function() {\n        return Math.atan2(this.matrix.d, this.matrix.c) * spine.radDeg;\n    },\n    getWorldScaleX: function() {\n        var a = this.matrix.a;\n        var b = this.matrix.b;\n        return Math.sqrt(a*a+b*b);\n    },\n    getWorldScaleY: function() {\n        var c = this.matrix.c;\n        var d = this.matrix.d;\n        return Math.sqrt(c * c + d * d);\n    }\n};\n\nObject.defineProperties(spine.Bone.prototype, {\n    worldX: {\n        get: function() {\n            return this.matrix.tx;\n        }\n    },\n    worldY:  {\n        get: function() {\n            return this.matrix.ty;\n        }\n    }\n});\n\nmodule.exports = spine.Bone;\n\n},{\"../SpineUtil\":45}],14:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.BoneData = function (name, parent)\n{\n    this.name = name;\n    this.parent = parent;\n};\nspine.BoneData.prototype = {\n    length: 0,\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1,\n    shearX: 0, shearY: 0,\n    inheritScale: true,\n    inheritRotation: true\n};\nmodule.exports = spine.BoneData;\n\n\n},{\"../SpineUtil\":45}],15:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.AttachmentType = require('./AttachmentType');\nspine.BoundingBoxAttachment = function (name)\n{\n    this.name = name;\n    this.vertices = [];\n};\nspine.BoundingBoxAttachment.prototype = {\n    type: spine.AttachmentType.boundingbox,\n    computeWorldVertices: function (x, y, bone, worldVertices)\n    {\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\n        var vertices = this.vertices;\n        for (var i = 0, n = vertices.length; i < n; i += 2)\n        {\n            var px = vertices[i];\n            var py = vertices[i + 1];\n            worldVertices[i] = px * m00 + py * m01 + x;\n            worldVertices[i + 1] = px * m10 + py * m11 + y;\n        }\n    }\n};\nmodule.exports = spine.BoundingBoxAttachment;\n\n\n},{\"../SpineUtil\":45,\"./AttachmentType\":12}],16:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.ColorTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, r, g, b, a, ...\n    this.frames.length = frameCount * 5;\n};\nspine.ColorTimeline.prototype = {\n    slotIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length / 5;\n    },\n    setFrame: function (frameIndex, time, r, g, b, a)\n    {\n        frameIndex *= 5;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = r;\n        this.frames[frameIndex + 2] = g;\n        this.frames[frameIndex + 3] = b;\n        this.frames[frameIndex + 4] = a;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var r, g, b, a;\n        if (time >= frames[frames.length - 5])\n        {\n            // Time is after last frame.\n            var i = frames.length - 1;\n            r = frames[i - 3];\n            g = frames[i - 2];\n            b = frames[i - 1];\n            a = frames[i];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            var frameIndex = spine.Animation.binarySearch(frames, time, 5);\n            var prevFrameR = frames[frameIndex - 4];\n            var prevFrameG = frames[frameIndex - 3];\n            var prevFrameB = frames[frameIndex - 2];\n            var prevFrameA = frames[frameIndex - 1];\n            var frameTime = frames[frameIndex];\n            var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*PREV_FRAME_TIME*/] - frameTime);\n            percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);\n\n            r = prevFrameR + (frames[frameIndex + 1/*FRAME_R*/] - prevFrameR) * percent;\n            g = prevFrameG + (frames[frameIndex + 2/*FRAME_G*/] - prevFrameG) * percent;\n            b = prevFrameB + (frames[frameIndex + 3/*FRAME_B*/] - prevFrameB) * percent;\n            a = prevFrameA + (frames[frameIndex + 4/*FRAME_A*/] - prevFrameA) * percent;\n        }\n        var slot = skeleton.slots[this.slotIndex];\n        if (alpha < 1)\n        {\n            slot.r += (r - slot.r) * alpha;\n            slot.g += (g - slot.g) * alpha;\n            slot.b += (b - slot.b) * alpha;\n            slot.a += (a - slot.a) * alpha;\n        } else {\n            slot.r = r;\n            slot.g = g;\n            slot.b = b;\n            slot.a = a;\n        }\n    }\n};\nmodule.exports = spine.ColorTimeline;\n\n\n},{\"../SpineUtil\":45,\"./Animation\":3,\"./Curves\":17}],17:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.Curves = function (frameCount)\n{\n    this.curves = []; // type, x, y, ...\n    //this.curves.length = (frameCount - 1) * 19/*BEZIER_SIZE*/;\n};\nspine.Curves.prototype = {\n    setLinear: function (frameIndex)\n    {\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 0/*LINEAR*/;\n    },\n    setStepped: function (frameIndex)\n    {\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 1/*STEPPED*/;\n    },\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\n     * the difference between the keyframe's values. */\n    setCurve: function (frameIndex, cx1, cy1, cx2, cy2)\n    {\n        var subdiv1 = 1 / 10/*BEZIER_SEGMENTS*/, subdiv2 = subdiv1 * subdiv1, subdiv3 = subdiv2 * subdiv1;\n        var pre1 = 3 * subdiv1, pre2 = 3 * subdiv2, pre4 = 6 * subdiv2, pre5 = 6 * subdiv3;\n        var tmp1x = -cx1 * 2 + cx2, tmp1y = -cy1 * 2 + cy2, tmp2x = (cx1 - cx2) * 3 + 1, tmp2y = (cy1 - cy2) * 3 + 1;\n        var dfx = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv3, dfy = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv3;\n        var ddfx = tmp1x * pre4 + tmp2x * pre5, ddfy = tmp1y * pre4 + tmp2y * pre5;\n        var dddfx = tmp2x * pre5, dddfy = tmp2y * pre5;\n\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\n        var curves = this.curves;\n        curves[i++] = 2/*BEZIER*/;\n\n        var x = dfx, y = dfy;\n        for (var n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\n        {\n            curves[i] = x;\n            curves[i + 1] = y;\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            x += dfx;\n            y += dfy;\n        }\n    },\n    getCurvePercent: function (frameIndex, percent)\n    {\n        percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);\n        var curves = this.curves;\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\n        var type = curves[i];\n        if (type === 0/*LINEAR*/) return percent;\n        if (type == 1/*STEPPED*/) return 0;\n        i++;\n        var x = 0;\n        for (var start = i, n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\n        {\n            x = curves[i];\n            if (x >= percent)\n            {\n                var prevX, prevY;\n                if (i == start)\n                {\n                    prevX = 0;\n                    prevY = 0;\n                } else {\n                    prevX = curves[i - 2];\n                    prevY = curves[i - 1];\n                }\n                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\n            }\n        }\n        var y = curves[i - 1];\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\n    }\n};\nmodule.exports = spine.Curves;\n\n\n},{\"../SpineUtil\":45}],18:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.DrawOrderTimeline = function (frameCount)\n{\n    this.frames = []; // time, ...\n    this.frames.length = frameCount;\n    this.drawOrders = [];\n    this.drawOrders.length = frameCount;\n};\nspine.DrawOrderTimeline.prototype = {\n    getFrameCount: function ()\n    {\n        return this.frames.length;\n    },\n    setFrame: function (frameIndex, time, drawOrder)\n    {\n        this.frames[frameIndex] = time;\n        this.drawOrders[frameIndex] = drawOrder;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var frameIndex;\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\n            frameIndex = frames.length - 1;\n        else\n            frameIndex = spine.Animation.binarySearch1(frames, time) - 1;\n\n        var drawOrder = skeleton.drawOrder;\n        var slots = skeleton.slots;\n        var drawOrderToSetupIndex = this.drawOrders[frameIndex];\n        if (drawOrderToSetupIndex)\n        {\n            for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\n            {\n                drawOrder[i] = drawOrderToSetupIndex[i];\n            }\n        }\n\n    }\n};\nmodule.exports = spine.DrawOrderTimeline;\n\n\n},{\"../SpineUtil\":45,\"./Animation\":3}],19:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.Event = function (data)\n{\n    this.data = data;\n};\nspine.Event.prototype = {\n    intValue: 0,\n    floatValue: 0,\n    stringValue: null\n};\nmodule.exports = spine.Event;\n\n\n},{\"../SpineUtil\":45}],20:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.EventData = function (name)\n{\n    this.name = name;\n};\nspine.EventData.prototype = {\n    intValue: 0,\n    floatValue: 0,\n    stringValue: null\n};\nmodule.exports = spine.EventData;\n\n\n},{\"../SpineUtil\":45}],21:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.EventTimeline = function (frameCount)\n{\n    this.frames = []; // time, ...\n    this.frames.length = frameCount;\n    this.events = [];\n    this.events.length = frameCount;\n};\nspine.EventTimeline.prototype = {\n    getFrameCount: function ()\n    {\n        return this.frames.length;\n    },\n    setFrame: function (frameIndex, time, event)\n    {\n        this.frames[frameIndex] = time;\n        this.events[frameIndex] = event;\n    },\n    /** Fires events for frames > lastTime and <= time. */\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        if (!firedEvents) return;\n\n        var frames = this.frames;\n        var frameCount = frames.length;\n\n        if (lastTime > time)\n        { // Fire events after last time for looped animations.\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);\n            lastTime = -1;\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\n            return;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var frameIndex;\n        if (lastTime < frames[0])\n            frameIndex = 0;\n        else\n        {\n            frameIndex = spine.Animation.binarySearch1(frames, lastTime);\n            var frame = frames[frameIndex];\n            while (frameIndex > 0)\n            { // Fire multiple events with the same frame.\n                if (frames[frameIndex - 1] != frame) break;\n                frameIndex--;\n            }\n        }\n        var events = this.events;\n        for (; frameIndex < frameCount && time >= frames[frameIndex]; frameIndex++)\n            firedEvents.push(events[frameIndex]);\n    }\n};\nmodule.exports = spine.EventTimeline;\n\n\n},{\"../SpineUtil\":45,\"./Animation\":3}],22:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.FfdTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = [];\n    this.frames.length = frameCount;\n    this.frameVertices = [];\n    this.frameVertices.length = frameCount;\n};\nspine.FfdTimeline.prototype = {\n    slotIndex: 0,\n    attachment: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length;\n    },\n    setFrame: function (frameIndex, time, vertices)\n    {\n        this.frames[frameIndex] = time;\n        this.frameVertices[frameIndex] = vertices;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var slot = skeleton.slots[this.slotIndex];\n        var slotAttachment = slot.attachment;\n        if (slotAttachment && (!slotAttachment.applyFFD || !slotAttachment.applyFFD(this.attachment))) return;\n\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var frameVertices = this.frameVertices;\n        var vertexCount = frameVertices[0].length;\n\n        var vertices = slot.attachmentVertices;\n        if (vertices.length != vertexCount) {\n            vertices = slot.attachmentVertices = [];\n            for (var k = 0; k < vertexCount; k++) vertices.push(0);\n            // Don't mix from uninitialized slot vertices.\n            alpha = 1;\n        }\n\n        if (time >= frames[frames.length - 1])\n        { // Time is after last frame.\n            var lastVertices = frameVertices[frames.length - 1];\n            if (alpha < 1)\n            {\n                for (var i = 0; i < vertexCount; i++)\n                    vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\n            } else {\n                for (var i = 0; i < vertexCount; i++)\n                    vertices[i] = lastVertices[i];\n            }\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frameIndex = spine.Animation.binarySearch1(frames, time);\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 1] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));\n\n        var prevVertices = frameVertices[frameIndex - 1];\n        var nextVertices = frameVertices[frameIndex];\n\n        if (alpha < 1)\n        {\n            for (var i = 0; i < vertexCount; i++)\n            {\n                var prev = prevVertices[i];\n                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\n            }\n        } else {\n            for (var i = 0; i < vertexCount; i++)\n            {\n                var prev = prevVertices[i];\n                vertices[i] = prev + (nextVertices[i] - prev) * percent;\n            }\n        }\n    }\n};\nmodule.exports = spine.FfdTimeline;\n\n\n},{\"../SpineUtil\":45,\"./Animation\":3,\"./Curves\":17}],23:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.IkConstraint = function (data, skeleton)\n{\n    this.data = data;\n    this.mix = data.mix;\n    this.bendDirection = data.bendDirection;\n\n    this.bones = [];\n    for (var i = 0, n = data.bones.length; i < n; i++)\n        this.bones.push(skeleton.findBone(data.bones[i].name));\n    this.target = skeleton.findBone(data.target.name);\n};\nspine.IkConstraint.prototype = {\n    update: function() {\n        this.apply();\n    },\n    apply: function ()\n    {\n        var target = this.target;\n        var bones = this.bones;\n        switch (bones.length)\n        {\n        case 1:\n            spine.IkConstraint.apply1(bones[0], target.worldX, target.worldY, this.mix);\n            break;\n        case 2:\n            spine.IkConstraint.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\n            break;\n        }\n    }\n};\n/** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n * coordinate system. */\nspine.IkConstraint.apply1 = function (bone, targetX, targetY, alpha)\n{\n    var parentRotation = bone.parent ? bone.parent.getWorldRotationX(): 0;\n    var rotation = bone.rotation;\n    var rotationIK = Math.atan2(targetY - bone.worldY, targetX - bone.worldX) * spine.radDeg - parentRotation;\n    if ((bone.worldSignX != bone.worldSignY) != (bone.skeleton.flipX != (bone.skeleton.flipY != spine.Bone.yDown))) rotationIK = 360 - rotationIK;\n    if (rotationIK > 180)\n        rotationIK -= 360;\n    else if (rotationIK < -180) rotationIK += 360;\n    bone.rotationIK = rotation + (rotationIK - rotation) * alpha;\n    bone.updateWorldTransform();\n};\n/** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n * target is specified in the world coordinate system.\n * @param child Any descendant bone of the parent. */\nspine.IkConstraint.apply2 = function (parent, child, targetX, targetY, bendDir, alpha)\n{\n    if (alpha == 0) return;\n    var px = parent.x, py = parent.y, psx = parent.scaleX, psy = parent.scaleY, csx = child.scaleX, cy = child.y;\n    var offset1, offset2, sign2;\n    if (psx < 0) {\n        psx = -psx;\n        offset1 = 180;\n        sign2 = -1;\n    } else {\n        offset1 = 0;\n        sign2 = 1;\n    }\n    if (psy < 0) {\n        psy = -psy;\n        sign2 = -sign2;\n    }\n    if (csx < 0) {\n        csx = -csx;\n        offset2 = 180;\n    } else\n        offset2 = 0;\n    var pp = parent.parent;\n    var ppm = pp.matrix;\n    var tx, ty, dx, dy;\n    if (pp == null) {\n        tx = targetX - px;\n        ty = targetY - py;\n        dx = child.worldX - px;\n        dy = child.worldY - py;\n    } else {\n        var a = ppm.a, b = ppm.c, c = ppm.b, d = ppm.d, invDet = 1 / (a * d - b * c);\n        var wx = ppm.tx, wy = ppm.ty, x = targetX - wx, y = targetY - wy;\n        tx = (x * d - y * b) * invDet - px;\n        ty = (y * a - x * c) * invDet - py;\n        x = child.worldX - wx;\n        y = child.worldY - wy;\n        dx = (x * d - y * b) * invDet - px;\n        dy = (y * a - x * c) * invDet - py;\n    }\n    var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;\n    outer:\n        if (Math.abs(psx - psy) <= 0.0001) {\n            l2 *= psx;\n            var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n            if (cos < -1)\n                cos = -1;\n            else if (cos > 1) cos = 1;\n            a2 = Math.acos(cos) * bendDir;\n            var a = l1 + l2 * cos, o = l2 * Math.sin(a2);\n            a1 = Math.atan2(ty * a - tx * o, tx * a + ty * o);\n        } else {\n            cy = 0;\n            var a = psx * l2, b = psy * l2, ta = Math.atan2(ty, tx);\n            var aa = a * a, bb = b * b, ll = l1 * l1, dd = tx * tx + ty * ty;\n            var c0 = bb * ll + aa * dd - aa * bb, c1 = -2 * bb * l1, c2 = bb - aa;\n            var d = c1 * c1 - 4 * c2 * c0;\n            if (d >= 0) {\n                var q = Math.sqrt(d);\n                if (c1 < 0) q = -q;\n                q = -(c1 + q) / 2;\n                var r0 = q / c2, r1 = c0 / q;\n                var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n                if (r * r <= dd) {\n                    var y = Math.sqrt(dd - r * r) * bendDir;\n                    a1 = ta - Math.atan2(y, r);\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\n                    break outer;\n                }\n            }\n            var minAngle = 0, minDist = Infinity, minX = 0, minY = 0;\n            var maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;\n            var x = l1 + a, dist = x * x;\n            if (dist > maxDist) {\n                maxAngle = 0;\n                maxDist = dist;\n                maxX = x;\n            }\n            x = l1 - a;\n            dist = x * x;\n            if (dist < minDist) {\n                minAngle = Math.PI;\n                minDist = dist;\n                minX = x;\n            }\n            var angle = Math.acos(-a * l1 / (aa - bb));\n            x = a * Math.cos(angle) + l1;\n            var y = b * Math.sin(angle);\n            dist = x * x + y * y;\n            if (dist < minDist) {\n                minAngle = angle;\n                minDist = dist;\n                minX = x;\n                minY = y;\n            }\n            if (dist > maxDist) {\n                maxAngle = angle;\n                maxDist = dist;\n                maxX = x;\n                maxY = y;\n            }\n            if (dd <= (minDist + maxDist) / 2) {\n                a1 = ta - Math.atan2(minY * bendDir, minX);\n                a2 = minAngle * bendDir;\n            } else {\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                a2 = maxAngle * bendDir;\n            }\n        }\n    var offset = Math.atan2(cy, child.x) * sign2;\n    a1 = (a1 - offset) * spine.radDeg + offset1;\n    a2 = (a2 + offset) * spine.radDeg * sign2 + offset2;\n    if (a1 > 180)\n        a1 -= 360;\n    else if (a1 < -180) a1 += 360;\n    if (a2 > 180)\n        a2 -= 360;\n    else if (a2 < -180) a2 += 360;\n    var rotation = parent.rotation;\n    parent.rotationIK = rotation + (a1 - rotation) * alpha;\n    parent.updateWorldTransform();\n    rotation = child.rotation;\n    child.rotationIK = rotation + (a2 - rotation) * alpha;\n    child.updateWorldTransform();\n};\nmodule.exports = spine.IkConstraint;\n\n\n},{\"../SpineUtil\":45}],24:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\nspine.IkConstraintData = function (name)\n{\n    this.name = name;\n    this.bones = [];\n};\nspine.IkConstraintData.prototype = {\n    target: null,\n    bendDirection: 1,\n    mix: 1\n};\nmodule.exports = spine.IkConstraintData;\n\n\n},{\"../SpineUtil\":45}],25:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.IkConstraintTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, mix, bendDirection, ...\n    this.frames.length = frameCount * 3;\n};\nspine.IkConstraintTimeline.prototype = {\n    ikConstraintIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length / 3;\n    },\n    setFrame: function (frameIndex, time, mix, bendDirection)\n    {\n        frameIndex *= 3;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = mix;\n        this.frames[frameIndex + 2] = bendDirection;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var ikConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\n\n        if (time >= frames[frames.length - 3])\n        { // Time is after last frame.\n            ikConstraint.mix += (frames[frames.length - 2] - ikConstraint.mix) * alpha;\n            ikConstraint.bendDirection = frames[frames.length - 1];\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\n        var prevFrameMix = frames[frameIndex + -2/*PREV_FRAME_MIX*/];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\n\n        var mix = prevFrameMix + (frames[frameIndex + 1/*FRAME_MIX*/] - prevFrameMix) * percent;\n        ikConstraint.mix += (mix - ikConstraint.mix) * alpha;\n        ikConstraint.bendDirection = frames[frameIndex + -1/*PREV_FRAME_BEND_DIRECTION*/];\n    }\n};\nmodule.exports = spine.IkConstraintTimeline;\n\n\n},{\"../SpineUtil\":45,\"./Animation\":3,\"./Curves\":17}],26:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\nspine.AttachmentType = require('./AttachmentType');\nspine.MeshAttachment = function (name)\n{\n    this.name = name;\n};\nspine.MeshAttachment.prototype = {\n    type: spine.AttachmentType.mesh,\n    parentMesh: null,\n    inheritFFD: false,\n    vertices: null,\n    uvs: null,\n    regionUVs: null,\n    triangles: null,\n    hullLength: 0,\n    r: 1, g: 1, b: 1, a: 1,\n    path: null,\n    rendererObject: null,\n    edges: null,\n    width: 0, height: 0,\n    updateUVs: function ()\n    {\n        var n = this.regionUVs.length;\n        if (!this.uvs || this.uvs.length != n)\n        {\n            this.uvs = new spine.Float32Array(n);\n        }\n        var region = this.rendererObject;\n        if (!region) return;\n        var texture = region.texture;\n        var r = texture._uvs;\n        var w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\n        var x = region.offsetX, y = region.pixiOffsetY;\n        for (var i = 0; i < n; i += 2)\n        {\n            var u = this.regionUVs[i], v = this.regionUVs[i+1];\n            u = (u * w2 - x) / w1;\n            v = (v * h2 - y) / h1;\n            this.uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1-v) + (r.x3 * (1 - u) + r.x2 * u) * v;\n            this.uvs[i+1] = (r.y0 * (1 - u) + r.y1 * u) * (1-v) + (r.y3 * (1 - u) + r.y2 * u) * v;\n        }\n    },\n    computeWorldVertices: function (x, y, slot, worldVertices)\n    {\n        var bone = slot.bone;\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\n        var vertices = this.vertices;\n        var verticesCount = vertices.length;\n        if (slot.attachmentVertices.length == verticesCount) vertices = slot.attachmentVertices;\n        for (var i = 0; i < verticesCount; i += 2)\n        {\n            var vx = vertices[i];\n            var vy = vertices[i + 1];\n            worldVertices[i] = vx * m00 + vy * m01 + x;\n            worldVertices[i + 1] = vx * m10 + vy * m11 + y;\n        }\n    },\n    applyFFD: function(sourceAttachment) {\n        return this === sourceAttachment || (this.inheritFFD && parentMesh === sourceAttachment);\n    },\n    setParentMesh: function(parentMesh) {\n        this.parentMesh = parentMesh;\n        if (parentMesh != null) {\n            this.vertices = parentMesh.vertices;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n        }\n    }\n};\nmodule.exports = spine.MeshAttachment;\n\n\n},{\"../SpineUtil\":45,\"./AttachmentType\":12}],27:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.AttachmentType = require('./AttachmentType');\nspine.RegionAttachment = function (name)\n{\n    this.name = name;\n    this.offset = [];\n    this.offset.length = 8;\n    this.uvs = [];\n    this.uvs.length = 8;\n};\nspine.RegionAttachment.prototype = {\n    type: spine.AttachmentType.region,\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1,\n    width: 0, height: 0,\n    r: 1, g: 1, b: 1, a: 1,\n    path: null,\n    rendererObject: null,\n    regionOffsetX: 0, regionOffsetY: 0,\n    regionWidth: 0, regionHeight: 0,\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\n    setUVs: function (u, v, u2, v2, rotate)\n    {\n        var uvs = this.uvs;\n        if (rotate)\n        {\n            uvs[2/*X2*/] = u;\n            uvs[3/*Y2*/] = v2;\n            uvs[4/*X3*/] = u;\n            uvs[5/*Y3*/] = v;\n            uvs[6/*X4*/] = u2;\n            uvs[7/*Y4*/] = v;\n            uvs[0/*X1*/] = u2;\n            uvs[1/*Y1*/] = v2;\n        } else {\n            uvs[0/*X1*/] = u;\n            uvs[1/*Y1*/] = v2;\n            uvs[2/*X2*/] = u;\n            uvs[3/*Y2*/] = v;\n            uvs[4/*X3*/] = u2;\n            uvs[5/*Y3*/] = v;\n            uvs[6/*X4*/] = u2;\n            uvs[7/*Y4*/] = v2;\n        }\n    },\n    updateOffset: function ()\n    {\n        var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;\n        var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;\n        var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;\n        var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;\n        var localX2 = localX + this.regionWidth * regionScaleX;\n        var localY2 = localY + this.regionHeight * regionScaleY;\n        var radians = this.rotation * spine.degRad;\n        var cos = Math.cos(radians);\n        var sin = Math.sin(radians);\n        var localXCos = localX * cos + this.x;\n        var localXSin = localX * sin;\n        var localYCos = localY * cos + this.y;\n        var localYSin = localY * sin;\n        var localX2Cos = localX2 * cos + this.x;\n        var localX2Sin = localX2 * sin;\n        var localY2Cos = localY2 * cos + this.y;\n        var localY2Sin = localY2 * sin;\n        var offset = this.offset;\n        offset[0/*X1*/] = localXCos - localYSin;\n        offset[1/*Y1*/] = localYCos + localXSin;\n        offset[2/*X2*/] = localXCos - localY2Sin;\n        offset[3/*Y2*/] = localY2Cos + localXSin;\n        offset[4/*X3*/] = localX2Cos - localY2Sin;\n        offset[5/*Y3*/] = localY2Cos + localX2Sin;\n        offset[6/*X4*/] = localX2Cos - localYSin;\n        offset[7/*Y4*/] = localYCos + localX2Sin;\n    },\n    computeVertices: function (x, y, bone, vertices)\n    {\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\n        var offset = this.offset;\n        vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;\n        vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;\n        vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;\n        vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;\n        vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;\n        vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;\n        vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;\n        vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;\n    }\n};\nmodule.exports = spine.RegionAttachment;\n\n\n},{\"../SpineUtil\":45,\"./AttachmentType\":12}],28:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.RotateTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, angle, ...\n    this.frames.length = frameCount * 2;\n};\nspine.RotateTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length / 2;\n    },\n    setFrame: function (frameIndex, time, angle)\n    {\n        frameIndex *= 2;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = angle;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - 2])\n        { // Time is after last frame.\n            var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;\n            while (amount > 180)\n                amount -= 360;\n            while (amount < -180)\n                amount += 360;\n            bone.rotation += amount * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frameIndex = spine.Animation.binarySearch(frames, time, 2);\n        var prevFrameValue = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);\n\n        var amount = frames[frameIndex + 1/*FRAME_VALUE*/] - prevFrameValue;\n        while (amount > 180)\n            amount -= 360;\n        while (amount < -180)\n            amount += 360;\n        amount = bone.data.rotation + (prevFrameValue + amount * percent) - bone.rotation;\n        while (amount > 180)\n            amount -= 360;\n        while (amount < -180)\n            amount += 360;\n        bone.rotation += amount * alpha;\n    }\n};\nmodule.exports = spine.RotateTimeline;\n\n\n},{\"../SpineUtil\":45,\"./Animation\":3,\"./Curves\":17}],29:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.ScaleTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, x, y, ...\n    this.frames.length = frameCount * 3;\n};\nspine.ScaleTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length / 3;\n    },\n    setFrame: function (frameIndex, time, x, y)\n    {\n        frameIndex *= 3;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = x;\n        this.frames[frameIndex + 2] = y;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - 3])\n        { // Time is after last frame.\n            bone.scaleX += (bone.data.scaleX * frames[frames.length - 2] - bone.scaleX) * alpha;\n            bone.scaleY += (bone.data.scaleY * frames[frames.length - 1] - bone.scaleY) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\n        var prevFrameX = frames[frameIndex - 2];\n        var prevFrameY = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\n\n        bone.scaleX += (bone.data.scaleX * (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.scaleX) * alpha;\n        bone.scaleY += (bone.data.scaleY * (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.scaleY) * alpha;\n    }\n};\nmodule.exports = spine.ScaleTimeline;\n\n\n},{\"../SpineUtil\":45,\"./Animation\":3,\"./Curves\":17}],30:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.ShearTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, x, y, ...\n    this.frames.length = frameCount * 3;\n};\nspine.ShearTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length / 3;\n    },\n    setFrame: function (frameIndex, time, x, y)\n    {\n        frameIndex *= 3;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = x;\n        this.frames[frameIndex + 2] = y;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - 3])\n        { // Time is after last frame.\n            bone.shearX += (bone.data.shearX * frames[frames.length - 2] - bone.shearX) * alpha;\n            bone.shearY += (bone.data.shearY * frames[frames.length - 1] - bone.shearY) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\n        var prevFrameX = frames[frameIndex - 2];\n        var prevFrameY = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\n\n        bone.shearX += (bone.data.shearX + (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.shearX) * alpha;\n        bone.shearY += (bone.data.shearY + (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.shearY) * alpha;\n    }\n};\nmodule.exports = spine.ShearTimeline;\n\n\n},{\"../SpineUtil\":45,\"./Animation\":3,\"./Curves\":17}],31:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.Bone = require('./Bone');\nspine.Slot = require('./Slot');\nspine.IkConstraint = require('./IkConstraint');\nspine.Skeleton = function (skeletonData)\n{\n    this.data = skeletonData;\n\n    this.bones = [];\n    for (var i = 0, n = skeletonData.bones.length; i < n; i++)\n    {\n        var boneData = skeletonData.bones[i];\n        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];\n        this.bones.push(new spine.Bone(boneData, this, parent));\n    }\n\n    this.slots = [];\n    this.drawOrder = [];\n    for (var i = 0, n = skeletonData.slots.length; i < n; i++)\n    {\n        var slotData = skeletonData.slots[i];\n        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];\n        var slot = new spine.Slot(slotData, bone);\n        this.slots.push(slot);\n        this.drawOrder.push(i);\n    }\n\n    this.ikConstraints = [];\n    for (var i = 0, n = skeletonData.ikConstraints.length; i < n; i++)\n        this.ikConstraints.push(new spine.IkConstraint(skeletonData.ikConstraints[i], this));\n\n    this.transformConstraints = [];\n    for (var i = 0, n = skeletonData.transformConstraints.length; i < n; i++)\n        this.transformConstraints.push(new spine.TransformConstraint(skeletonData.transformConstraints[i], this));\n\n    this.boneCache = [];\n    this.updateCache();\n};\nspine.Skeleton.prototype = {\n    x: 0, y: 0,\n    skin: null,\n    r: 1, g: 1, b: 1, a: 1,\n    time: 0,\n    flipX: false, flipY: false,\n    /** Caches information about bones and IK constraints. Must be called if bones or IK constraints are added or removed. */\n    updateCache: function ()\n    {\n        var ikConstraints = this.ikConstraints;\n        var ikConstraintsCount = ikConstraints.length;\n        var transformConstraints = this.transformConstraints;\n        var transformConstraintsCount = transformConstraints.length;\n\n        var boneCache = this.boneCache;\n        boneCache.length = 0;\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var bone = bones[i];\n            boneCache.push(bone);\n            for (var j=0; j < transformConstraintsCount; j++) {\n                if (transformConstraints[j].bone == bone) {\n                    boneCache.push(transformConstraints[j]);\n                }\n            }\n            for (var j=0; j < ikConstraintsCount; j++) {\n                if (ikConstraints[j].bones[ikConstraints[j].bones.length-1] == bone) {\n                    boneCache.push(ikConstraints[j]);\n                    break;\n                }\n            }\n        }\n    },\n    /** Updates the world transform for each bone. */\n    updateWorldTransform: function ()\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var bone = bones[i];\n            bone.rotationIK = bone.rotation;\n        }\n        var boneCache = this.boneCache;\n        for (var i = 0, n = boneCache.length; i < n; i++) {\n            boneCache[i].update();\n        }\n    },\n    /** Sets the bones and slots to their setup pose values. */\n    setToSetupPose: function ()\n    {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    },\n    setBonesToSetupPose: function ()\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            bones[i].setToSetupPose();\n\n        var ikConstraints = this.ikConstraints;\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\n        {\n            var ikConstraint = ikConstraints[i];\n            ikConstraint.bendDirection = ikConstraint.data.bendDirection;\n            ikConstraint.mix = ikConstraint.data.mix;\n        }\n\n        var transformConstraints = this.transformConstraints;\n        for (var i = 0, n = transformConstraints.length; i < n; i++)\n        {\n            var constraint = transformConstraints[i];\n            var data = constraint.data;\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n            constraint.scaleMix = data.scaleMix;\n            constraint.shearMix = data.shearMix;\n        }\n    },\n    setSlotsToSetupPose: function ()\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            slots[i].setToSetupPose(i);\n        }\n\n        this.resetDrawOrder();\n    },\n    /** @return May return null. */\n    getRootBone: function ()\n    {\n        return this.bones.length ? this.bones[0] : null;\n    },\n    /** @return May be null. */\n    findBone: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return bones[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSlot: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return slots[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return i;\n        return -1;\n    },\n    setSkinByName: function (skinName)\n    {\n        var skin = this.data.findSkin(skinName);\n        if (!skin) throw \"Skin not found: \" + skinName;\n        this.setSkin(skin);\n    },\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was\n     * no old skin, each slot's setup mode attachment is attached from the new skin.\n     * @param newSkin May be null. */\n    setSkin: function (newSkin)\n    {\n        if (newSkin)\n        {\n            if (this.skin)\n                newSkin._attachAll(this, this.skin);\n            else\n            {\n                var slots = this.slots;\n                for (var i = 0, n = slots.length; i < n; i++)\n                {\n                    var slot = slots[i];\n                    var name = slot.data.attachmentName;\n                    if (name)\n                    {\n                        var attachment = newSkin.getAttachment(i, name);\n                        if (attachment) slot.setAttachment(attachment);\n                    }\n                }\n            }\n        }\n        this.skin = newSkin;\n    },\n    /** @return May be null. */\n    getAttachmentBySlotName: function (slotName, attachmentName)\n    {\n        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);\n    },\n    /** @return May be null. */\n    getAttachmentBySlotIndex: function (slotIndex, attachmentName)\n    {\n        if (this.skin)\n        {\n            var attachment = this.skin.getAttachment(slotIndex, attachmentName);\n            if (attachment) return attachment;\n        }\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n        return null;\n    },\n    /** @param attachmentName May be null. */\n    setAttachment: function (slotName, attachmentName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            var slot = slots[i];\n            if (slot.data.name == slotName)\n            {\n                var attachment = null;\n                if (attachmentName)\n                {\n                    attachment = this.getAttachmentBySlotIndex(i, attachmentName);\n                    if (!attachment) throw \"Attachment not found: \" + attachmentName + \", for slot: \" + slotName;\n                }\n                slot.setAttachment(attachment);\n                return;\n            }\n        }\n        throw \"Slot not found: \" + slotName;\n    },\n    /** @return May be null. */\n    findIkConstraint: function (constraintName)\n    {\n        var constraints = this.ikConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].data.name == constraintName) return constraints[i];\n        return null;\n    },\n    findTransformConstraint: function (constraintName)\n    {\n        var constraints = this.transformConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].data.name == constraintName) return constraints[i];\n        return null;\n    },\n    update: function (delta)\n    {\n        this.time += delta;\n    },\n    resetDrawOrder: function () {\n        for (var i = 0, n = this.drawOrder.length; i < n; i++)\n        {\n            this.drawOrder[i] = i;\n        }\n    }\n};\nmodule.exports = spine.Skeleton;\n\n\n},{\"../SpineUtil\":45,\"./Bone\":13,\"./IkConstraint\":23,\"./Slot\":36}],32:[function(require,module,exports){\nvar spine = require('../SpineRuntime') || {};\nspine.AttachmentType = require('./AttachmentType');\nspine.SkeletonBounds = function ()\n{\n    this.polygonPool = [];\n    this.polygons = [];\n    this.boundingBoxes = [];\n};\nspine.SkeletonBounds.prototype = {\n    minX: 0, minY: 0, maxX: 0, maxY: 0,\n    update: function (skeleton, updateAabb)\n    {\n        var slots = skeleton.slots;\n        var slotCount = slots.length;\n        var x = skeleton.x, y = skeleton.y;\n        var boundingBoxes = this.boundingBoxes;\n        var polygonPool = this.polygonPool;\n        var polygons = this.polygons;\n\n        boundingBoxes.length = 0;\n        for (var i = 0, n = polygons.length; i < n; i++)\n            polygonPool.push(polygons[i]);\n        polygons.length = 0;\n\n        for (var i = 0; i < slotCount; i++)\n        {\n            var slot = slots[i];\n            var boundingBox = slot.attachment;\n            if (boundingBox.type != spine.AttachmentType.boundingbox) continue;\n            boundingBoxes.push(boundingBox);\n\n            var poolCount = polygonPool.length, polygon;\n            if (poolCount > 0)\n            {\n                polygon = polygonPool[poolCount - 1];\n                polygonPool.splice(poolCount - 1, 1);\n            } else\n                polygon = [];\n            polygons.push(polygon);\n\n            polygon.length = boundingBox.vertices.length;\n            boundingBox.computeWorldVertices(x, y, slot.bone, polygon);\n        }\n\n        if (updateAabb) this.aabbCompute();\n    },\n    aabbCompute: function ()\n    {\n        var polygons = this.polygons;\n        var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;\n        for (var i = 0, n = polygons.length; i < n; i++)\n        {\n            var vertices = polygons[i];\n            for (var ii = 0, nn = vertices.length; ii < nn; ii += 2)\n            {\n                var x = vertices[ii];\n                var y = vertices[ii + 1];\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n                maxX = Math.max(maxX, x);\n                maxY = Math.max(maxY, y);\n            }\n        }\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    },\n    /** Returns true if the axis aligned bounding box contains the point. */\n    aabbContainsPoint: function (x, y)\n    {\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n    },\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\n    aabbIntersectsSegment: function (x1, y1, x2, y2)\n    {\n        var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\n            return false;\n        var m = (y2 - y1) / (x2 - x1);\n        var y = m * (minX - x1) + y1;\n        if (y > minY && y < maxY) return true;\n        y = m * (maxX - x1) + y1;\n        if (y > minY && y < maxY) return true;\n        var x = (minY - y1) / m + x1;\n        if (x > minX && x < maxX) return true;\n        x = (maxY - y1) / m + x1;\n        if (x > minX && x < maxX) return true;\n        return false;\n    },\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\n    aabbIntersectsSkeleton: function (bounds)\n    {\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n    },\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\n    containsPoint: function (x, y)\n    {\n        var polygons = this.polygons;\n        for (var i = 0, n = polygons.length; i < n; i++)\n            if (this.polygonContainsPoint(polygons[i], x, y)) return this.boundingBoxes[i];\n        return null;\n    },\n    /** Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually\n     * more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true. */\n    intersectsSegment: function (x1, y1, x2, y2)\n    {\n        var polygons = this.polygons;\n        for (var i = 0, n = polygons.length; i < n; i++)\n            if (polygons[i].intersectsSegment(x1, y1, x2, y2)) return this.boundingBoxes[i];\n        return null;\n    },\n    /** Returns true if the polygon contains the point. */\n    polygonContainsPoint: function (polygon, x, y)\n    {\n        var nn = polygon.length;\n        var prevIndex = nn - 2;\n        var inside = false;\n        for (var ii = 0; ii < nn; ii += 2)\n        {\n            var vertexY = polygon[ii + 1];\n            var prevY = polygon[prevIndex + 1];\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y))\n            {\n                var vertexX = polygon[ii];\n                if (vertexX + (y - vertexY) / (prevY - vertexY) * (polygon[prevIndex] - vertexX) < x) inside = !inside;\n            }\n            prevIndex = ii;\n        }\n        return inside;\n    },\n    /** Returns true if the polygon contains the line segment. */\n    polygonIntersectsSegment: function (polygon, x1, y1, x2, y2)\n    {\n        var nn = polygon.length;\n        var width12 = x1 - x2, height12 = y1 - y2;\n        var det1 = x1 * y2 - y1 * x2;\n        var x3 = polygon[nn - 2], y3 = polygon[nn - 1];\n        for (var ii = 0; ii < nn; ii += 2)\n        {\n            var x4 = polygon[ii], y4 = polygon[ii + 1];\n            var det2 = x3 * y4 - y3 * x4;\n            var width34 = x3 - x4, height34 = y3 - y4;\n            var det3 = width12 * height34 - height12 * width34;\n            var x = (det1 * width34 - width12 * det2) / det3;\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1)))\n            {\n                var y = (det1 * height34 - height12 * det2) / det3;\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\n            }\n            x3 = x4;\n            y3 = y4;\n        }\n        return false;\n    },\n    getPolygon: function (attachment)\n    {\n        var index = this.boundingBoxes.indexOf(attachment);\n        return index == -1 ? null : this.polygons[index];\n    },\n    getWidth: function ()\n    {\n        return this.maxX - this.minX;\n    },\n    getHeight: function ()\n    {\n        return this.maxY - this.minY;\n    }\n};\nmodule.exports = spine.SkeletonBounds;\n\n\n},{\"../SpineRuntime\":44,\"./AttachmentType\":12}],33:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.SkeletonData = function ()\n{\n    this.bones = [];\n    this.slots = [];\n    this.skins = [];\n    this.events = [];\n    this.animations = [];\n    this.ikConstraints = [];\n    this.transformConstraints = [];\n};\nspine.SkeletonData.prototype = {\n    name: null,\n    defaultSkin: null,\n    width: 0, height: 0,\n    version: null, hash: null,\n    /** @return May be null. */\n    findBone: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return bones[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSlot: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            if (slots[i].name == slotName) return this.slots[i];\n        }\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].name == slotName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSkin: function (skinName)\n    {\n        var skins = this.skins;\n        for (var i = 0, n = skins.length; i < n; i++)\n            if (skins[i].name == skinName) return skins[i];\n        return null;\n    },\n    /** @return May be null. */\n    findEvent: function (eventName)\n    {\n        var events = this.events;\n        for (var i = 0, n = events.length; i < n; i++)\n            if (events[i].name == eventName) return events[i];\n        return null;\n    },\n    /** @return May be null. */\n    findAnimation: function (animationName)\n    {\n        var animations = this.animations;\n        for (var i = 0, n = animations.length; i < n; i++)\n            if (animations[i].name == animationName) return animations[i];\n        return null;\n    },\n    /** @return May be null. */\n    findIkConstraint: function (constraintName)\n    {\n        var constraints = this.ikConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].name == constraintName) return constraints[i];\n        return null;\n    },\n    /** @return May be null. */\n    findTransformConstraint: function (constraintName)\n    {\n        var constraints = this.transformConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].name == constraintName) return constraints[i];\n        return null;\n    },\n};\nmodule.exports = spine.SkeletonData;\n\n\n},{\"../SpineUtil\":45}],34:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.SkeletonData = require('./SkeletonData');\nspine.BoneData = require('./BoneData');\nspine.IkConstraintData = require('./IkConstraintData');\nspine.TransformConstraintData = require('./TransformConstraintData');\nspine.SlotData = require('./SlotData');\nspine.Skin = require('./Skin');\nspine.EventData = require('./EventData');\nspine.AttachmentType = require('./AttachmentType');\nspine.ColorTimeline = require('./ColorTimeline');\nspine.AttachmentTimeline = require('./AttachmentTimeline');\nspine.RotateTimeline = require('./RotateTimeline');\nspine.ScaleTimeline = require('./ScaleTimeline');\nspine.TranslateTimeline = require('./TranslateTimeline');\nspine.ShearTimeline = require('./ShearTimeline');\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\nspine.TransformConstraintTimeline = require('./TransformConstraintTimeline');\nspine.FfdTimeline = require('./FfdTimeline');\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\nspine.EventTimeline = require('./EventTimeline');\nspine.Event = require('./Event');\nspine.Animation = require('./Animation');\n\nfunction LinkedMesh(mesh, skin, slotIndex, parent) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n}\n\nspine.SkeletonJsonParser = function (attachmentLoader)\n{\n    if (attachmentLoader.pages) {\n        //its an atlas, we have to wrap it\n        this.attachmentLoader = new spine.AtlasAttachmentLoader(attachmentLoader);\n    } else {\n        //got a loader, thats good\n        this.attachmentLoader = attachmentLoader;\n    }\n    if (!attachmentLoader.newRegionAttachment) {\n        console.warn(\"SkeletonJsonParser accepts AtlasAttachmentLoader or atlas as first parameter\");\n    }\n    this.linkedMeshes = [];\n};\nspine.SkeletonJsonParser.prototype = {\n    scale: 1,\n    readSkeletonData: function (root, name)\n    {\n        var skeletonData = new spine.SkeletonData();\n        skeletonData.name = name;\n\n        var scale = this.scale;\n        // Skeleton.\n        var skeletonMap = root[\"skeleton\"];\n        if (skeletonMap)\n        {\n            skeletonData.hash = skeletonMap[\"hash\"];\n            skeletonData.version = skeletonMap[\"spine\"];\n            skeletonData.width = skeletonMap[\"width\"] || 0;\n            skeletonData.height = skeletonMap[\"height\"] || 0;\n        }\n\n        // Bones.\n        var bones = root[\"bones\"];\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var boneMap = bones[i];\n            var parent = null;\n            if (boneMap[\"parent\"])\n            {\n                parent = skeletonData.findBone(boneMap[\"parent\"]);\n                if (!parent) throw \"Parent bone not found: \" + boneMap[\"parent\"];\n            }\n            var boneData = new spine.BoneData(boneMap[\"name\"], parent);\n            boneData.length = (boneMap[\"length\"] || 0) * this.scale;\n            boneData.x = (boneMap[\"x\"] || 0) * this.scale;\n            boneData.y = (boneMap[\"y\"] || 0) * this.scale;\n            boneData.rotation = (boneMap[\"rotation\"] || 0);\n            boneData.scaleX = boneMap.hasOwnProperty(\"scaleX\") ? boneMap[\"scaleX\"] : 1;\n            boneData.scaleY = boneMap.hasOwnProperty(\"scaleY\") ? boneMap[\"scaleY\"] : 1;\n            boneData.shearX = boneMap[\"shearX\"] || 0;\n            boneData.shearY = boneMap[\"shearY\"] || 0;\n            boneData.inheritScale = boneMap.hasOwnProperty(\"inheritScale\") ? boneMap[\"inheritScale\"] : true;\n            boneData.inheritRotation = boneMap.hasOwnProperty(\"inheritRotation\") ? boneMap[\"inheritRotation\"] : true;\n            skeletonData.bones.push(boneData);\n        }\n\n        // IK constraints.\n        var ik = root[\"ik\"];\n        if (ik)\n        {\n            for (var i = 0, n = ik.length; i < n; i++)\n            {\n                var ikMap = ik[i];\n                var ikConstraintData = new spine.IkConstraintData(ikMap[\"name\"]);\n\n                var bones = ikMap[\"bones\"];\n                for (var ii = 0, nn = bones.length; ii < nn; ii++)\n                {\n                    var bone = skeletonData.findBone(bones[ii]);\n                    if (!bone) throw new Error( \"IK bone not found: \" + bones[ii] );\n                    ikConstraintData.bones.push(bone);\n                }\n\n                ikConstraintData.target = skeletonData.findBone(ikMap[\"target\"]);\n                if (!ikConstraintData.target) throw new Error(\"Target bone not found: \" + ikMap[\"target\"]);\n\n                ikConstraintData.bendDirection = (!ikMap.hasOwnProperty(\"bendPositive\") || ikMap[\"bendPositive\"]) ? 1 : -1;\n                ikConstraintData.mix = ikMap.hasOwnProperty(\"mix\") ? ikMap[\"mix\"] : 1;\n\n                skeletonData.ikConstraints.push(ikConstraintData);\n            }\n        }\n\n        var transform = root[\"transform\"];\n        if (transform) {\n            for (var i = 0, n = transform.length; i<n; i++) {\n                var transformMap = transform[i];\n                var transformData = new spine.TransformConstraintData(transformMap[\"name\"]);\n                transformData.bone = skeletonData.findBone(transformMap[\"bone\"]);\n                if (!transformData.bone) throw new Error(\"Transform bone not found: \" + transformData[\"bone\"]);\n                transformData.target = skeletonData.findBone(transformMap[\"target\"]);\n                if (!transformData.target) throw new Error(\"Target bone not found: \" + transformData[\"target\"]);\n\n                transformData.offsetRotation = transformMap[\"rotation\"] || 0;\n                transformData.offsetX = (transformMap[\"offsetX\"] || 0) * scale;\n                transformData.offsetY = (transformMap[\"offsetY\"] || 0) * scale;\n                transformData.offsetScaleX = (transformMap[\"scaleX\"] || 0) * scale;\n                transformData.offsetScaleY = (transformMap[\"scaleY\"] || 0) * scale;\n                transformData.offsetShearY = (transformMap[\"offsetShearY\"] || 0) * scale;\n\n                transformData.rotateMix = transformMap.hasOwnProperty(\"rotateMix\") ? transformMap[\"rotateMix\"] : 1;\n                transformData.translateMix = transformMap.hasOwnProperty(\"translateMix\") ? transformMap[\"translateMix\"] : 1;\n                transformData.scaleMix = transformMap.hasOwnProperty(\"scaleMix\") ? transformMap[\"scaleMix\"] : 1;\n                transformData.shearMix = transformMap.hasOwnProperty(\"shearMix\") ? transformMap[\"shearMix\"] : 1;\n\n                skeletonData.transformConstraints.push(transformData);\n            }\n        }\n\n        // Slots.\n        var slots = root[\"slots\"];\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            var slotMap = slots[i];\n            var boneData = skeletonData.findBone(slotMap[\"bone\"]);\n            if (!boneData) throw \"Slot bone not found: \" + slotMap[\"bone\"];\n            var slotData = new spine.SlotData(slotMap[\"name\"], boneData);\n\n            var color = slotMap[\"color\"];\n            if (color)\n            {\n                slotData.r = this.toColor(color, 0);\n                slotData.g = this.toColor(color, 1);\n                slotData.b = this.toColor(color, 2);\n                slotData.a = this.toColor(color, 3);\n            }\n\n            slotData.attachmentName = slotMap[\"attachment\"];\n\n\n            slotData.blendMode = slotMap[\"blend\"] && spine.SlotData.PIXI_BLEND_MODE_MAP[slotMap[\"blend\"]] || spine.SlotData.PIXI_BLEND_MODE_MAP['normal'];\n\n            skeletonData.slots.push(slotData);\n        }\n\n        // Skins.\n        var skins = root[\"skins\"];\n        for (var skinName in skins)\n        {\n            if (!skins.hasOwnProperty(skinName)) continue;\n            var skinMap = skins[skinName];\n            var skin = new spine.Skin(skinName);\n            for (var slotName in skinMap)\n            {\n                if (!skinMap.hasOwnProperty(slotName)) continue;\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var slotEntry = skinMap[slotName];\n                for (var attachmentName in slotEntry)\n                {\n                    if (!slotEntry.hasOwnProperty(attachmentName)) continue;\n                    var attachment = this.readAttachment(skin, slotIndex, attachmentName, slotEntry[attachmentName]);\n                    if (attachment) skin.addAttachment(slotIndex, attachmentName, attachment);\n                }\n            }\n            skeletonData.skins.push(skin);\n            if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n        }\n\n        var linkedMeshes = this.linkedMeshes;\n        // Linked meshes.\n        for (var i = 0, n = linkedMeshes.size; i < n; i++) {\n            var linkedMesh = linkedMeshes[i];\n            var skin = linkedMesh.skin ? skeletonData.findSkin(linkedMesh.skin): skeletonData.defaultSkin;\n            var parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n            linkedMesh.mesh.setParentMesh(parent);\n            linkedMesh.mesh.updateUVs();\n        }\n        linkedMeshes.length = 0;\n\n        // Events.\n        var events = root[\"events\"];\n        for (var eventName in events)\n        {\n            if (!events.hasOwnProperty(eventName)) continue;\n            var eventMap = events[eventName];\n            var eventData = new spine.EventData(eventName);\n            eventData.intValue = eventMap[\"int\"] || 0;\n            eventData.floatValue = eventMap[\"float\"] || 0;\n            eventData.stringValue = eventMap[\"string\"] || null;\n            skeletonData.events.push(eventData);\n        }\n\n        // Animations.\n        var animations = root[\"animations\"];\n        for (var animationName in animations)\n        {\n            if (!animations.hasOwnProperty(animationName)) continue;\n            this.readAnimation(animationName, animations[animationName], skeletonData);\n        }\n\n        return skeletonData;\n    },\n    readAttachment: function (skin, slotIndex, name, map)\n    {\n        name = map[\"name\"] || name;\n\n        var type = spine.AttachmentType[map[\"type\"] || \"region\"];\n        var path = map[\"path\"] || name;\n\n        var scale = this.scale;\n        if (type == spine.AttachmentType.region)\n        {\n            var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n            if (!region) return null;\n            region.path = path;\n            region.x = (map[\"x\"] || 0) * scale;\n            region.y = (map[\"y\"] || 0) * scale;\n            region.scaleX = map.hasOwnProperty(\"scaleX\") ? map[\"scaleX\"] : 1;\n            region.scaleY = map.hasOwnProperty(\"scaleY\") ? map[\"scaleY\"] : 1;\n            region.rotation = map[\"rotation\"] || 0;\n            region.width = (map[\"width\"] || 0) * scale;\n            region.height = (map[\"height\"] || 0) * scale;\n\n            var color = map[\"color\"];\n            if (color)\n            {\n                region.r = this.toColor(color, 0);\n                region.g = this.toColor(color, 1);\n                region.b = this.toColor(color, 2);\n                region.a = this.toColor(color, 3);\n            }\n\n            region.updateOffset();\n            return region;\n        } else if (type == spine.AttachmentType.boundingbox)\n        {\n            var attachment = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n            var vertices = map[\"vertices\"];\n            for (var i = 0, n = vertices.length; i < n; i++)\n                attachment.vertices.push(vertices[i] * scale);\n            return attachment;\n        } else if (type == spine.AttachmentType.mesh || type == spine.AttachmentType.linkedmesh)\n        {\n            var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n            if (!mesh) return null;\n            mesh.path = path;\n            color = map[\"color\"];\n            if (color)\n            {\n                mesh.r = this.toColor(color, 0);\n                mesh.g = this.toColor(color, 1);\n                mesh.b = this.toColor(color, 2);\n                mesh.a = this.toColor(color, 3);\n            }\n            mesh.width = (map[\"width\"] || 0) * scale;\n            mesh.height = (map[\"height\"] || 0) * scale;\n\n            var parent = map[\"parent\"];\n            if (!parent) {\n                mesh.vertices = this.getFloatArray(map, \"vertices\", scale);\n                mesh.triangles = this.getIntArray(map, \"triangles\");\n                mesh.regionUVs = this.getFloatArray(map, \"uvs\", 1);\n                mesh.updateUVs();\n                mesh.hullLength = (map[\"hull\"] || 0) * 2;\n                if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\n            } else {\n                mesh.inheritFFD = !!map[\"ffd\"];\n                this.linkedMeshes.push(new LinkedMesh(mesh, map[\"skin\"] || null, slotIndex, parent));\n            }\n            return mesh;\n        } else if (type == spine.AttachmentType.weightedmesh || type == spine.AttachmentType.weightedlinkedmesh)\n        {\n            var mesh = this.attachmentLoader.newWeightedMeshAttachment(skin, name, path);\n            if (!mesh) return null;\n            mesh.path = path;\n            color = map[\"color\"];\n            if (color)\n            {\n                mesh.r = this.toColor(color, 0);\n                mesh.g = this.toColor(color, 1);\n                mesh.b = this.toColor(color, 2);\n                mesh.a = this.toColor(color, 3);\n            }\n            mesh.width = (map[\"width\"] || 0) * scale;\n            mesh.height = (map[\"height\"] || 0) * scale;\n\n            var parent = map[\"parent\"];\n            if (!parent) {\n                var uvs = this.getFloatArray(map, \"uvs\", 1);\n                var vertices = this.getFloatArray(map, \"vertices\", 1);\n                var weights = [];\n                var bones = [];\n                for (var i = 0, n = vertices.length; i < n; )\n                {\n                    var boneCount = vertices[i++] | 0;\n                    bones[bones.length] = boneCount;\n                    for (var nn = i + boneCount * 4; i < nn; )\n                    {\n                        bones[bones.length] = vertices[i];\n                        weights[weights.length] = vertices[i + 1] * scale;\n                        weights[weights.length] = vertices[i + 2] * scale;\n                        weights[weights.length] = vertices[i + 3];\n                        i += 4;\n                    }\n                }\n                mesh.bones = bones;\n                mesh.weights = weights;\n                mesh.triangles = this.getIntArray(map, \"triangles\");\n                mesh.regionUVs = uvs;\n                mesh.updateUVs();\n\n                mesh.hullLength = (map[\"hull\"] || 0) * 2;\n                if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\n            } else {\n                mesh.inheritFFD = !!map[\"ffd\"];\n                this.linkedMeshes.push(new LinkedMesh(mesh, map[\"skin\"] || null, slotIndex, parent));\n            }\n            return mesh;\n        }\n        throw \"Unknown attachment type: \" + type;\n    },\n    readAnimation: function (name, map, skeletonData)\n    {\n        var timelines = [];\n        var duration = 0;\n\n        var slots = map[\"slots\"];\n        for (var slotName in slots)\n        {\n            if (!slots.hasOwnProperty(slotName)) continue;\n            var slotMap = slots[slotName];\n            var slotIndex = skeletonData.findSlotIndex(slotName);\n\n            for (var timelineName in slotMap)\n            {\n                if (!slotMap.hasOwnProperty(timelineName)) continue;\n                var values = slotMap[timelineName];\n                if (timelineName == \"color\")\n                {\n                    var timeline = new spine.ColorTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var color = valueMap[\"color\"];\n                        var r = this.toColor(color, 0);\n                        var g = this.toColor(color, 1);\n                        var b = this.toColor(color, 2);\n                        var a = this.toColor(color, 3);\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], r, g, b, a);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\n\n                } else if (timelineName == \"attachment\")\n                {\n                    var timeline = new spine.AttachmentTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex++, valueMap[\"time\"], valueMap[\"name\"]);\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n\n                } else\n                    throw \"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\";\n            }\n        }\n\n        var bones = map[\"bones\"];\n        for (var boneName in bones)\n        {\n            if (!bones.hasOwnProperty(boneName)) continue;\n            var boneIndex = skeletonData.findBoneIndex(boneName);\n            if (boneIndex == -1) throw \"Bone not found: \" + boneName;\n            var boneMap = bones[boneName];\n\n            for (var timelineName in boneMap)\n            {\n                if (!boneMap.hasOwnProperty(timelineName)) continue;\n                var values = boneMap[timelineName];\n                if (timelineName == \"rotate\")\n                {\n                    var timeline = new spine.RotateTimeline(values.length);\n                    timeline.boneIndex = boneIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[\"angle\"]);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\n\n                } else if (timelineName == \"translate\" || timelineName == \"scale\" || timelineName == \"shear\")\n                {\n                    var timeline;\n                    var timelineScale = 1;\n                    if (timelineName == \"scale\") {\n                        timeline = new spine.ScaleTimeline(values.length);\n                    } else if (timelineName == \"shear\") {\n                        timeline = new spine.ShearTimeline(values.length);\n                    }\n                    else\n                    {\n                        timeline = new spine.TranslateTimeline(values.length);\n                        timelineScale = this.scale;\n                    }\n                    timeline.boneIndex = boneIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var x = (valueMap[\"x\"] || 0) * timelineScale;\n                        var y = (valueMap[\"y\"] || 0) * timelineScale;\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], x, y);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n\n                } else if (timelineName == \"flipX\" || timelineName == \"flipY\")\n                {\n                    throw \"flipX and flipY are not supported in spine v3: (\" + boneName + \")\";\n                } else\n                    throw \"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\";\n            }\n        }\n\n        var ikMap = map[\"ik\"];\n        for (var ikConstraintName in ikMap)\n        {\n            if (!ikMap.hasOwnProperty(ikConstraintName)) continue;\n            var ikConstraint = skeletonData.findIkConstraint(ikConstraintName);\n            var values = ikMap[ikConstraintName];\n            var timeline = new spine.IkConstraintTimeline(values.length);\n            timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(ikConstraint);\n            var frameIndex = 0;\n            for (var i = 0, n = values.length; i < n; i++)\n            {\n                var valueMap = values[i];\n                var mix = valueMap.hasOwnProperty(\"mix\") ? valueMap[\"mix\"] : 1;\n                var bendDirection = (!valueMap.hasOwnProperty(\"bendPositive\") || valueMap[\"bendPositive\"]) ? 1 : -1;\n                timeline.setFrame(frameIndex, valueMap[\"time\"], mix, bendDirection);\n                this.readCurve(timeline, frameIndex, valueMap);\n                frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n        }\n\n        var transformMap = map[\"transform\"];\n        for (var transformConstraintName in transformMap)\n        {\n            if (!transformMap.hasOwnProperty(transformConstraintName)) continue;\n            var transformConstraint = skeletonData.findTransformConstraint(transformConstraintName);\n            var values = transformMap[transformConstraintName];\n            var timeline = new spine.TransformConstraintTimeline(values.length);\n            timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(transformConstraint);\n            var frameIndex = 0;\n            for (var i = 0, n = values.length; i < n; i++)\n            {\n                var valueMap = values[i];\n                var rotateMix = valueMap.hasOwnProperty(\"rotateMix\") ? valueMap[\"rotateMix\"] : 1;\n                var translateMix = valueMap.hasOwnProperty(\"translateMix\") ? valueMap[\"translateMix\"] : 1;\n                var scaleMix = valueMap.hasOwnProperty(\"scaleMix\") ? valueMap[\"scaleMix\"] : 1;\n                var shearMix = valueMap.hasOwnProperty(\"shearMix\") ? valueMap[\"shearMix\"] : 1;\n                timeline.setFrame(frameIndex, valueMap[\"time\"], translateMix, scaleMix, shearMix);\n                this.readCurve(timeline, frameIndex, valueMap);\n                frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\n        }\n\n        var ffd = map[\"ffd\"];\n        for (var skinName in ffd)\n        {\n            var skin = skeletonData.findSkin(skinName);\n            var slotMap = ffd[skinName];\n            for (slotName in slotMap)\n            {\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var meshMap = slotMap[slotName];\n                for (var meshName in meshMap)\n                {\n                    var values = meshMap[meshName];\n                    var timeline = new spine.FfdTimeline(values.length);\n                    var attachment = skin.getAttachment(slotIndex, meshName);\n                    if (!attachment) throw \"FFD attachment not found: \" + meshName;\n                    timeline.slotIndex = slotIndex;\n                    timeline.attachment = attachment;\n\n                    var isMesh = attachment.type == spine.AttachmentType.mesh;\n                    var vertexCount;\n                    if (isMesh)\n                        vertexCount = attachment.vertices.length;\n                    else\n                        vertexCount = attachment.weights.length / 3 * 2;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var vertices;\n                        if (!valueMap[\"vertices\"])\n                        {\n                            if (isMesh)\n                                vertices = attachment.vertices;\n                            else\n                            {\n                                vertices = [];\n                                for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\n                            }\n                        } else {\n                            var verticesValue = valueMap[\"vertices\"];\n                            vertices = [];\n                            for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\n                            var start = valueMap[\"offset\"] || 0;\n                            var nn = verticesValue.length;\n                            if (this.scale == 1)\n                            {\n                                for (var ii = 0; ii < nn; ii++)\n                                    vertices[ii + start] = verticesValue[ii];\n                            } else {\n                                for (var ii = 0; ii < nn; ii++)\n                                    vertices[ii + start] = verticesValue[ii] * this.scale;\n                            }\n                            if (isMesh)\n                            {\n                                var meshVertices = attachment.vertices;\n                                for (var ii = 0, nn = vertices.length; ii < nn; ii++)\n                                    vertices[ii] += meshVertices[ii];\n                            }\n                        }\n\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], vertices);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines[timelines.length] = timeline;\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                }\n            }\n        }\n\n        var drawOrderValues = map[\"drawOrder\"];\n        if (!drawOrderValues) drawOrderValues = map[\"draworder\"];\n        if (drawOrderValues)\n        {\n            var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);\n            var slotCount = skeletonData.slots.length;\n            var frameIndex = 0;\n            for (var i = 0, n = drawOrderValues.length; i < n; i++)\n            {\n                var drawOrderMap = drawOrderValues[i];\n                var drawOrder = null;\n                if (drawOrderMap[\"offsets\"])\n                {\n                    drawOrder = [];\n                    drawOrder.length = slotCount;\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\n                        drawOrder[ii] = -1;\n                    var offsets = drawOrderMap[\"offsets\"];\n                    var unchanged = [];\n                    unchanged.length = slotCount - offsets.length;\n                    var originalIndex = 0, unchangedIndex = 0;\n                    for (var ii = 0, nn = offsets.length; ii < nn; ii++)\n                    {\n                        var offsetMap = offsets[ii];\n                        var slotIndex = skeletonData.findSlotIndex(offsetMap[\"slot\"]);\n                        if (slotIndex == -1) throw \"Slot not found: \" + offsetMap[\"slot\"];\n                        // Collect unchanged items.\n                        while (originalIndex != slotIndex)\n                            unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap[\"offset\"]] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount)\n                        unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\n                        if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frameIndex++, drawOrderMap[\"time\"], drawOrder);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        var events = map[\"events\"];\n        if (events)\n        {\n            var timeline = new spine.EventTimeline(events.length);\n            var frameIndex = 0;\n            for (var i = 0, n = events.length; i < n; i++)\n            {\n                var eventMap = events[i];\n                var eventData = skeletonData.findEvent(eventMap[\"name\"]);\n                if (!eventData) throw \"Event not found: \" + eventMap[\"name\"];\n                var event = new spine.Event(eventData);\n                event.intValue = eventMap.hasOwnProperty(\"int\") ? eventMap[\"int\"] : eventData.intValue;\n                event.floatValue = eventMap.hasOwnProperty(\"float\") ? eventMap[\"float\"] : eventData.floatValue;\n                event.stringValue = eventMap.hasOwnProperty(\"string\") ? eventMap[\"string\"] : eventData.stringValue;\n                timeline.setFrame(frameIndex++, eventMap[\"time\"], event);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        skeletonData.animations.push(new spine.Animation(name, timelines, duration));\n    },\n    readCurve: function (timeline, frameIndex, valueMap)\n    {\n        var curve = valueMap[\"curve\"];\n        if (!curve)\n            timeline.curves.setLinear(frameIndex);\n        else if (curve == \"stepped\")\n            timeline.curves.setStepped(frameIndex);\n        else if (curve instanceof Array)\n            timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n    },\n    toColor: function (hexString, colorIndex)\n    {\n        if (hexString.length != 8) throw \"Color hexidecimal length must be 8, recieved: \" + hexString;\n        return parseInt(hexString.substring(colorIndex * 2, (colorIndex * 2) + 2), 16) / 255;\n    },\n    getFloatArray: function (map, name, scale)\n    {\n        var list = map[name];\n        var values = new spine.Float32Array(list.length);\n        var i = 0, n = list.length;\n        if (scale == 1)\n        {\n            for (; i < n; i++)\n                values[i] = list[i];\n        } else {\n            for (; i < n; i++)\n                values[i] = list[i] * scale;\n        }\n        return values;\n    },\n    getIntArray: function (map, name)\n    {\n        var list = map[name];\n        var values = new spine.Uint16Array(list.length);\n        for (var i = 0, n = list.length; i < n; i++)\n            values[i] = list[i] | 0;\n        return values;\n    }\n};\nmodule.exports = spine.SkeletonJsonParser;\n\n\n},{\"../SpineUtil\":45,\"./Animation\":3,\"./AttachmentTimeline\":11,\"./AttachmentType\":12,\"./BoneData\":14,\"./ColorTimeline\":16,\"./DrawOrderTimeline\":18,\"./Event\":19,\"./EventData\":20,\"./EventTimeline\":21,\"./FfdTimeline\":22,\"./IkConstraintData\":24,\"./IkConstraintTimeline\":25,\"./RotateTimeline\":28,\"./ScaleTimeline\":29,\"./ShearTimeline\":30,\"./SkeletonData\":33,\"./Skin\":35,\"./SlotData\":37,\"./TransformConstraintData\":40,\"./TransformConstraintTimeline\":41,\"./TranslateTimeline\":42}],35:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.Skin = function (name)\n{\n    this.name = name;\n    this.attachments = {};\n};\nspine.Skin.prototype = {\n    addAttachment: function (slotIndex, name, attachment)\n    {\n        this.attachments[slotIndex + \":\" + name] = attachment;\n    },\n    getAttachment: function (slotIndex, name)\n    {\n        return this.attachments[slotIndex + \":\" + name];\n    },\n    _attachAll: function (skeleton, oldSkin)\n    {\n        for (var key in oldSkin.attachments)\n        {\n            var colon = key.indexOf(\":\");\n            var slotIndex = parseInt(key.substring(0, colon));\n            var name = key.substring(colon + 1);\n            var slot = skeleton.slots[slotIndex];\n            if (slot.attachment && (slot.attachment.name === name) || (slot.data.attachmentName === name))\n            {\n                var attachment = this.getAttachment(slotIndex, name);\n                if (attachment) slot.setAttachment(attachment);\n            }\n        }\n    }\n};\nmodule.exports = spine.Skin;\n\n\n},{\"../SpineUtil\":45}],36:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.Slot = function (slotData, bone)\n{\n    this.data = slotData;\n    this.bone = bone;\n    this.setToSetupPose();\n};\nspine.Slot.prototype = {\n    r: 1, g: 1, b: 1, a: 1,\n    _attachmentTime: 0,\n    attachment: null,\n    attachmentVertices: [],\n    setAttachment: function (attachment)\n    {\n        this.attachment = attachment;\n        this._attachmentTime = this.bone.skeleton.time;\n        this.attachmentVertices.length = 0;\n    },\n    setAttachmentTime: function (time)\n    {\n        this._attachmentTime = this.bone.skeleton.time - time;\n    },\n    getAttachmentTime: function ()\n    {\n        return this.bone.skeleton.time - this._attachmentTime;\n    },\n    setToSetupPose: function ()\n    {\n        var data = this.data;\n        this.r = data.r;\n        this.g = data.g;\n        this.b = data.b;\n        this.a = data.a;\n        this.blendMode = data.blendMode;\n\n        var slotDatas = this.bone.skeleton.data.slots;\n        for (var i = 0, n = slotDatas.length; i < n; i++)\n        {\n            if (slotDatas[i] == data)\n            {\n                this.setAttachment(!data.attachmentName ? null : this.bone.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));\n                break;\n            }\n        }\n    }\n};\nmodule.exports = spine.Slot;\n\n\n},{\"../SpineUtil\":45}],37:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.SlotData = function (name, boneData)\n{\n    this.name = name;\n    this.boneData = boneData;\n};\n\nspine.SlotData.PIXI_BLEND_MODE_MAP = {\n    'multiply': PIXI.BLEND_MODES.MULTIPLY,\n    'screen': PIXI.BLEND_MODES.SCREEN,\n    'additive': PIXI.BLEND_MODES.ADD,\n    'normal': PIXI.BLEND_MODES.NORMAL\n};\n\nspine.SlotData.prototype = {\n    r: 1, g: 1, b: 1, a: 1,\n    attachmentName: null,\n    blendMode: PIXI.BLEND_MODES.NORMAL\n\n\n};\n\n\nmodule.exports = spine.SlotData;\n\n\n},{\"../SpineUtil\":45}],38:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.TrackEntry = function ()\n{};\nspine.TrackEntry.prototype = {\n    next: null, previous: null,\n    animation: null,\n    loop: false,\n    delay: 0, time: 0, lastTime: -1, endTime: 0,\n    timeScale: 1,\n    mixTime: 0, mixDuration: 0, mix: 1,\n    onStart: null, onEnd: null, onComplete: null, onEvent: null\n};\nmodule.exports = spine.TrackEntry;\n\n\n},{\"../SpineUtil\":45}],39:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nvar tempVec = [0, 0];\nspine.TransformConstraint = function (data, skeleton)\n{\n    this.data = data;\n    this.translateMix = data.translateMix;\n    this.rotateMix = data.rotateMix;\n    this.scaleMix = data.scaleMix;\n    this.shearMix = data.shearMix;\n    this.offsetX = data.offsetX;\n    this.offsetY = data.offsetY;\n    this.offsetScaleX = data.offsetScaleX;\n    this.offsetScaleY = data.offsetScaleY;\n    this.offsetShearY = data.offsetShearY;\n\n    this.bone = skeleton.findBone(data.bone.name);\n    this.target = skeleton.findBone(data.target.name);\n};\n\nspine.TransformConstraint.prototype = {\n    update: function() {\n        this.apply();\n    },\n    apply: function ()\n    {\n        var bm = this.bone.matrix;\n        var tm = this.target.matrix;\n\n        var rotateMix = this.rotateMix;\n        if (rotateMix > 0) {\n            var a = bm.a, b = bm.c, c = bm.b, d = bm.d;\n            var r = Math.atan2(tm.b, tm.a) - Math.atan2(c, a);\n            if (r > Math.PI)\n                r -= Math.PI*2;\n            else if (r < -Math.PI) r += Math.PI*2;\n            r *= rotateMix;\n            var cos = Math.cos(r), sin = Math.sin(r);\n            bm.a = cos * a - sin * c;\n            bm.c = cos * b - sin * d;\n            bm.b = sin * a + cos * c;\n            bm.d = sin * b + cos * d;\n        }\n\n        var scaleMix = this.rotateMix;\n        if (scaleMix > 0) {\n            var bs = Math.sqrt(bm.a * bm.a + bm.b * bm.b);\n            var ts = Math.sqrt(tm.a * tm.a + tm.b * tm.b);\n            var s = bs > 0.00001 ? (bs + (ts - bs + this.offsetScaleX) * scaleMix) / bs : 0;\n            bm.a *= s;\n            bm.b *= s;\n            bs = Math.sqrt(bm.c * bm.c + bm.d * bm.d);\n            ts = Math.sqrt(bm.c * bm.c + bm.d * bm.d);\n            s = bs > 0.00001 ? (bs + (ts - bs + this.offsetScaleY) * scaleMix) / bs : 0;\n            bm.c *= s;\n            bm.d *= s;\n        }\n\n        var shearMix = this.shearMix;\n        if (shearMix > 0) {\n            var b = bm.c, d = bm.d;\n            var by = Math.atan2(d, b);\n            var r = Math.atan2(tm.d, tm.c) - Math.atan2(tm.b, target.a) - (by - Math.atan2(bm.b, bm.a));\n            if (r > Math.PI)\n                r -= Math.PI*2;\n            else if (r < -Math.PI) r += Math.PI*2;\n            r = by + (r + this.offsetShearY * spine.degRad) * shearMix;\n            var s = Math.sqrt(b * b + d * d);\n            bm.c = Math.cos(r) * s;\n            bm.d = Math.sin(r) * s;\n        }\n\n        var translateMix = this.translateMix;\n        if (translateMix > 0) {\n            tempVec[0] = this.offsetX;\n            tempVec[1] = this.offsetY;\n            this.target.localToWorld(tempVec);\n            bm.tx += (tempVec[0] - bm.tx) * translateMix;\n            bm.ty += (tempVec[1] - bm.ty) * translateMix;\n        }\n    }\n};\n\nmodule.exports = spine.TransformConstraint;\n\n},{\"../SpineUtil\":45}],40:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\nspine.TransformConstraintData = function (name)\n{\n    this.name = name;\n    this.bone = null;\n};\nspine.TransformConstraintData.prototype = {\n    target: null,\n    rotateMix: 1,\n    translateMix: 1,\n    scaleMix: 1,\n    shearMix: 1,\n    offsetRotation: 0,\n    offsetX: 0,\n    offsetY: 0,\n    offsetScaleX: 0,\n    offsetScaleY: 0,\n    offsetShearY: 0\n};\nmodule.exports = spine.TransformConstraintData;\n\n\n},{\"../SpineUtil\":45}],41:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.TransformConstraintTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, mix, bendDirection, ...\n    this.frames.length = frameCount * 3;\n};\nspine.TransformConstraintTimeline.prototype = {\n    transformConstraintIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length / 5;\n    },\n    setFrame: function (frameIndex, time, rotateMix, translateMix, scaleMix, shareMix)\n    {\n        frameIndex *= 5;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = rotateMix;\n        this.frames[frameIndex + 2] = translateMix;\n        this.frames[frameIndex + 3] = scaleMix;\n        this.frames[frameIndex + 4] = shareMix;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var constraint = skeleton.transformConstraints[this.transformConstraintIndex];\n\n        if (time >= frames[frames.length - 5])\n        { // Time is after last frame.\n            constraint.rotateMix += (frames[i - 3] - constraint.rotateMix) * alpha;\n            constraint.translateMix += (frames[i - 2] - constraint.translateMix) * alpha;\n            constraint.scaleMix += (frames[i - 1] - constraint.scaleMix) * alpha;\n            constraint.shearMix += (frames[i] - constraint.shearMix) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frame = spine.Animation.binarySearch(frames, time, 5);\n        var frameTime = frames[frame];\n        var percent = 1 - (time - frameTime) / (frames[frame + -5/*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frame / 5 - 1, percent);\n\n        var rotate = frames[frame + -4/*PREV_ROTATE_MIX*/];\n        var translate = frames[frame + -3/*PREV_TRANSLATE_MIX*/];\n        var scale = frames[frame + -2/*PREV_SCALE_MIX*/];\n        var shear = frames[frame + -1/*PREV_SHEAR_MIX*/];\n        constraint.rotateMix += (rotate + (frames[frame + 1/*ROTATE_MIX*/] - rotate) * percent - constraint.rotateMix) * alpha;\n        constraint.translateMix += (translate + (frames[frame + 2/*TRANSLATE_MIX*/] - translate) * percent - constraint.translateMix)\n            * alpha;\n        constraint.scaleMix += (scale + (frames[frame + 3/*SCALE_MIX*/] - scale) * percent - constraint.scaleMix) * alpha;\n        constraint.shearMix += (shear + (frames[frame + 4/*SHEAR_MIX*/] - shear) * percent - constraint.shearMix) * alpha;\n    }\n};\nmodule.exports = spine.TransformConstraintTimeline;\n\n\n},{\"../SpineUtil\":45,\"./Animation\":3,\"./Curves\":17}],42:[function(require,module,exports){\nvar spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.TranslateTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, x, y, ...\n    this.frames.length = frameCount * 3;\n};\nspine.TranslateTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length / 3;\n    },\n    setFrame: function (frameIndex, time, x, y)\n    {\n        frameIndex *= 3;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = x;\n        this.frames[frameIndex + 2] = y;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - 3])\n        { // Time is after last frame.\n            bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;\n            bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\n        var prevFrameX = frames[frameIndex - 2];\n        var prevFrameY = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\n\n        bone.x += (bone.data.x + prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent - bone.x) * alpha;\n        bone.y += (bone.data.y + prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent - bone.y) * alpha;\n    }\n};\nmodule.exports = spine.TranslateTimeline;\n\n\n},{\"../SpineUtil\":45,\"./Animation\":3,\"./Curves\":17}],43:[function(require,module,exports){\nvar spine = require('../SpineUtil') || {};\nspine.AttachmentType = require('./AttachmentType');\nspine.WeightedMeshAttachment = function (name)\n{\n    this.name = name;\n};\nspine.WeightedMeshAttachment.prototype = {\n    type: spine.AttachmentType.weightedmesh,\n    parentMesh: null,\n    inheritFFD: false,\n    bones: null,\n    weights: null,\n    uvs: null,\n    regionUVs: null,\n    triangles: null,\n    hullLength: 0,\n    r: 1, g: 1, b: 1, a: 1,\n    path: null,\n    rendererObject: null,\n    edges: null,\n    width: 0, height: 0,\n    updateUVs: function (u, v, u2, v2, rotate)\n    {\n        var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;\n        var n = this.regionUVs.length;\n        if (!this.uvs || this.uvs.length != n)\n        {\n            this.uvs = new spine.Float32Array(n);\n        }\n        var region = this.rendererObject;\n        if (!region) return;\n        var texture = region.texture;\n        var r = texture._uvs;\n        var w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\n        var x = region.offsetX, y = region.pixiOffsetY;\n        for (var i = 0; i < n; i += 2)\n        {\n            var u = this.regionUVs[i], v = this.regionUVs[i+1];\n            u = (u * w2 - x) / w1;\n            v = (v * h2 - y) / h1;\n            this.uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1-v) + (r.x3 * (1 - u) + r.x2 * u) * v;\n            this.uvs[i+1] = (r.y0 * (1 - u) + r.y1 * u) * (1-v) + (r.y3 * (1 - u) + r.y2 * u) * v;\n        }\n    },\n    computeWorldVertices: function (x, y, slot, worldVertices)\n    {\n        var skeletonBones = slot.bone.skeleton.bones;\n        var weights = this.weights;\n        var bones = this.bones;\n\n        var w = 0, v = 0, b = 0, f = 0, n = bones.length, nn;\n        var wx, wy, vx, vy, weight;\n        var m;\n        if (!slot.attachmentVertices.length)\n        {\n            for (; v < n; w += 2)\n            {\n                wx = 0;\n                wy = 0;\n                nn = bones[v++] + v;\n                for (; v < nn; v++, b += 3)\n                {\n                    m = skeletonBones[bones[v]].matrix;\n                    vx = weights[b];\n                    vy = weights[b + 1];\n                    weight = weights[b + 2];\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\n                }\n                worldVertices[w] = wx + x;\n                worldVertices[w + 1] = wy + y;\n            }\n        } else {\n            var ffd = slot.attachmentVertices;\n            for (; v < n; w += 2)\n            {\n                wx = 0;\n                wy = 0;\n                nn = bones[v++] + v;\n                for (; v < nn; v++, b += 3, f += 2)\n                {\n                    m = skeletonBones[bones[v]].matrix;\n                    vx = weights[b] + ffd[f];\n                    vy = weights[b + 1] + ffd[f + 1];\n                    weight = weights[b + 2];\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\n                }\n                worldVertices[w] = wx + x;\n                worldVertices[w + 1] = wy + y;\n            }\n        }\n    },\n    applyFFD: function(sourceAttachment) {\n        return this === sourceAttachment || (this.inheritFFD && parentMesh === sourceAttachment);\n    },\n    setParentMesh: function(parentMesh) {\n        this.parentMesh = parentMesh;\n        if (parentMesh != null) {\n            this.bones = parentMesh.bones;\n            this.weights = parentMesh.weights;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n        }\n    }\n};\nmodule.exports = spine.WeightedMeshAttachment;\n\n\n},{\"../SpineUtil\":45,\"./AttachmentType\":12}],44:[function(require,module,exports){\n/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.1\n *\n * Copyright (c) 2013, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable and\n * non-transferable license to install, execute and perform the Spine Runtimes\n * Software (the \"Software\") solely for internal use. Without the written\n * permission of Esoteric Software (typically granted by licensing Spine), you\n * may not (a) modify, translate, adapt or otherwise create derivative works,\n * improvements of the Software or develop new applications using the Software\n * or (b) remove, delete, alter or obscure any trademarks or any copyright,\n * trademark, patent or other intellectual property or proprietary rights\n * notices on or in the Software, including any copy thereof. Redistributions\n * in binary or source form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\nvar spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.AnimationStateData = require('./AnimationStateData');\nspine.AnimationState = require('./AnimationState');\nspine.AtlasAttachmentParser = require('./AtlasAttachmentParser');\nspine.Atlas = require('./Atlas');\nspine.AtlasPage = require('./AtlasPage');\nspine.AtlasReader = require('./AtlasReader');\nspine.AtlasRegion = require('./AtlasRegion');\nspine.AttachmentTimeline = require('./AttachmentTimeline');\nspine.AttachmentType = require('./AttachmentType');\nspine.BoneData = require('./BoneData');\nspine.Bone = require('./Bone');\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\nspine.ColorTimeline = require('./ColorTimeline');\nspine.Curves = require('./Curves');\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\nspine.EventData = require('./EventData');\nspine.Event = require('./Event');\nspine.EventTimeline = require('./EventTimeline');\nspine.FfdTimeline = require('./FfdTimeline');\nspine.IkConstraintData = require('./IkConstraintData');\nspine.IkConstraint = require('./IkConstraint');\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\nspine.TransformConstraintData = require('./TransformConstraintData');\nspine.TransformConstraint = require('./TransformConstraint');\nspine.TransformConstraintTimeline = require('./TransformConstraintTimeline');\nspine.MeshAttachment = require('./MeshAttachment');\nspine.RegionAttachment = require('./RegionAttachment');\nspine.RotateTimeline = require('./RotateTimeline');\nspine.ScaleTimeline = require('./ScaleTimeline');\nspine.ShearTimeline = require('./ShearTimeline');\nspine.SkeletonBounds = require('./SkeletonBounds');\nspine.SkeletonData = require('./SkeletonData');\nspine.Skeleton = require('./Skeleton');\nspine.SkeletonJsonParser = require('./SkeletonJsonParser');\nspine.Skin = require('./Skin.js');\nspine.WeightedMeshAttachment = require('./WeightedMeshAttachment');\nspine.SlotData = require('./SlotData');\nspine.Slot = require('./Slot');\nspine.TrackEntry = require('./TrackEntry');\nspine.TranslateTimeline = require('./TranslateTimeline');\nmodule.exports = spine;\n\n},{\"../SpineUtil\":45,\"./Animation\":3,\"./AnimationState\":4,\"./AnimationStateData\":5,\"./Atlas\":6,\"./AtlasAttachmentParser\":7,\"./AtlasPage\":8,\"./AtlasReader\":9,\"./AtlasRegion\":10,\"./AttachmentTimeline\":11,\"./AttachmentType\":12,\"./Bone\":13,\"./BoneData\":14,\"./BoundingBoxAttachment\":15,\"./ColorTimeline\":16,\"./Curves\":17,\"./DrawOrderTimeline\":18,\"./Event\":19,\"./EventData\":20,\"./EventTimeline\":21,\"./FfdTimeline\":22,\"./IkConstraint\":23,\"./IkConstraintData\":24,\"./IkConstraintTimeline\":25,\"./MeshAttachment\":26,\"./RegionAttachment\":27,\"./RotateTimeline\":28,\"./ScaleTimeline\":29,\"./ShearTimeline\":30,\"./Skeleton\":31,\"./SkeletonBounds\":32,\"./SkeletonData\":33,\"./SkeletonJsonParser\":34,\"./Skin.js\":35,\"./Slot\":36,\"./SlotData\":37,\"./TrackEntry\":38,\"./TransformConstraint\":39,\"./TransformConstraintData\":40,\"./TransformConstraintTimeline\":41,\"./TranslateTimeline\":42,\"./WeightedMeshAttachment\":43}],45:[function(require,module,exports){\nmodule.exports = {\n    radDeg: 180 / Math.PI,\n    degRad: Math.PI / 180,\n    temp: [],\n    Float32Array: (typeof(Float32Array) === 'undefined') ? Array : Float32Array,\n    Uint16Array: (typeof(Uint16Array) === 'undefined') ? Array : Uint16Array,\n    signum: function(x) {\n        if (x>0) return 1;\n        if (x<0) return -1;\n        return 0;\n    }\n};\n\n\n},{}],46:[function(require,module,exports){\n/**\n * @file        Spine resource loader\n * @author      Ivan Popelyshev <ivan.popelyshev@gmail.com>\n * @copyright   2013-2015 GoodBoyDigital\n * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}\n */\n\n/**\n * @namespace PIXI.loaders\n */\n\nvar atlasParser = require('./atlasParser');\n\nPIXI.loaders.Loader.addPixiMiddleware(atlasParser);\nPIXI.loader.use(atlasParser());\n\n},{\"./atlasParser\":47}],47:[function(require,module,exports){\nvar Resource = PIXI.loaders.Resource,\n    spine = require('../SpineRuntime'),\n    imageLoaderAdapter = require('./imageLoaderAdapter');\n\nvar atlasParser = module.exports = function () {\n    return function (resource, next) {\n        // skip if no data, its not json, or it isn't atlas data\n        if (!resource.data || !resource.isJson || !resource.data.bones) {\n            return next();\n        }\n\n        var metadataAtlas = resource.metadata ? resource.metadata.spineAtlas: null;\n        if (metadataAtlas === false) {\n            return next();\n        }\n        if (metadataAtlas && metadataAtlas.pages) {\n            //its an atlas!\n            var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(metadataAtlas));\n            var skeletonData = spineJsonParser.readSkeletonData(resource.data);\n\n            resource.spineData = skeletonData;\n            resource.spineAtlas = metadataAtlas;\n            if (atlasParser.enableCaching) {\n                atlasParser.AnimCache[resource.name] = resource.spineData;\n            }\n\n            next();\n        }\n\n        /**\n         * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\n         * that correspond to the spine file are in the same base URL and that the .json and .atlas files\n         * have the same name\n         */\n        var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + '.atlas';\n        //remove the baseUrl\n        atlasPath = atlasPath.replace(this.baseUrl, '');\n\n        var atlasOptions = {\n            crossOrigin: resource.crossOrigin,\n            xhrType: Resource.XHR_RESPONSE_TYPE.TEXT,\n            metadata: resource.metadata ? resource.metadata.spineMetadata : null\n        };\n        var imageOptions = {\n            crossOrigin: resource.crossOrigin,\n            metadata: resource.metadata ? resource.metadata.imageMetadata: null\n        };\n        var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\n        //remove the baseUrl\n        baseUrl = baseUrl.replace(this.baseUrl, '');\n\n        var adapter = imageLoaderAdapter(this, resource.name + '_atlas_page_', baseUrl, imageOptions);\n\n        this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (res) {\n            new spine.Atlas(this.xhr.responseText, adapter, function(spineAtlas) {\n                var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(spineAtlas));\n                var skeletonData = spineJsonParser.readSkeletonData(resource.data);\n\n                resource.spineData = skeletonData;\n                resource.spineAtlas = spineAtlas;\n                if (atlasParser.enableCaching) {\n                    atlasParser.AnimCache[resource.name] = resource.spineData;\n                }\n\n                next();\n            });\n        });\n    };\n};\n\natlasParser.AnimCache = {};\natlasParser.enableCaching = false;\n\n},{\"../SpineRuntime\":44,\"./imageLoaderAdapter\":48}],48:[function(require,module,exports){\nvar spine = require('../SpineRuntime');\n\nmodule.exports = function (loader, namePrefix, baseUrl, imageOptions) {\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\n    {\n        baseUrl += '/';\n    }\n    return function(line, callback) {\n        var name = namePrefix + line;\n        var url = baseUrl + line;\n        loader.add(name, url, imageOptions, function(resource) {\n            callback(resource.texture.baseTexture);\n        });\n    }\n};\n\n},{\"../SpineRuntime\":44}],49:[function(require,module,exports){\nmodule.exports = {\n    atlasParser: require('./atlasParser'),\n    Loader: require('./Loader'),\n    syncImageLoaderAdapter: require('./syncImageLoaderAdapter'),\n    imageLoaderAdapter: require('./imageLoaderAdapter')\n};\n\n},{\"./Loader\":46,\"./atlasParser\":47,\"./imageLoaderAdapter\":48,\"./syncImageLoaderAdapter\":50}],50:[function(require,module,exports){\nvar spine = require('../SpineRuntime');\n\nmodule.exports = function (baseUrl, crossOrigin) {\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\n    {\n        baseUrl += '/';\n    }\n    return function(line, callback) {\n        callback(PIXI.BaseTexture.fromImage(line, crossOrigin));\n    }\n};\n\n},{\"../SpineRuntime\":44}]},{},[1])\n\n","var spine = require('../SpineRuntime');\nvar atlasParser = require('../loaders/atlasParser');\n\n/* Esoteric Software SPINE wrapper for pixi.js */\nspine.Bone.yDown = true;\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * ```js\n * var spineAnimation = new PIXI.Spine(spineData);\n * ```\n *\n * @class\n * @extends Container\n * @memberof PIXI.spine\n * @param spineData {object} The spine data loaded from a spine atlas.\n */\nfunction Spine(spineData)\n{\n    PIXI.Container.call(this);\n\n    if (!spineData)\n    {\n        throw new Error('The spineData param is required.');\n    }\n\n    if ((typeof spineData) === \"string\")\n    {\n        throw new Error('spineData param cant be string. Please use PIXI.spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n    }\n\n    /**\n     * The spineData object\n     *\n     * @member {object}\n     */\n    this.spineData = spineData;\n\n    /**\n     * A spine Skeleton object\n     *\n     * @member {object}\n     */\n    this.skeleton = new spine.Skeleton(spineData);\n    this.skeleton.updateWorldTransform();\n\n    /**\n     * A spine AnimationStateData object created from the spine data passed in the constructor\n     *\n     * @member {object}\n     */\n    this.stateData = new spine.AnimationStateData(spineData);\n\n    /**\n     * A spine AnimationState object created from the spine AnimationStateData object\n     *\n     * @member {object}\n     */\n    this.state = new spine.AnimationState(this.stateData);\n\n    /**\n     * An array of containers\n     *\n     * @member {Container[]}\n     */\n    this.slotContainers = [];\n\n    for (var i = 0, n = this.skeleton.slots.length; i < n; i++)\n    {\n        var slot = this.skeleton.slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = new PIXI.Container();\n        this.slotContainers.push(slotContainer);\n        this.addChild(slotContainer);\n\n        if (attachment instanceof spine.RegionAttachment)\n        {\n            var spriteName = attachment.rendererObject.name;\n            var sprite = this.createSprite(slot, attachment);\n            slot.currentSprite = sprite;\n            slot.currentSpriteName = spriteName;\n            slotContainer.addChild(sprite);\n        }\n        else if (attachment instanceof spine.MeshAttachment)\n        {\n            var mesh = this.createMesh(slot, attachment);\n            slot.currentMesh = mesh;\n            slot.currentMeshName = attachment.name;\n            slotContainer.addChild(mesh);\n        }\n        else\n        {\n            continue;\n        }\n\n    }\n\n    /**\n     * Should the Spine object update its transforms\n     *\n     * @member {boolean}\n     */\n    this.autoUpdate = true;\n}\n\nSpine.fromAtlas = function(resourceName) {\n    var skeletonData = atlasParser.AnimCache[resourceName];\n\n    if (!skeletonData)\n    {\n        throw new Error('Spine data \"' + resourceName + '\" does not exist in the animation cache');\n    }\n\n    return new Spine(skeletonData);\n}\n\nSpine.prototype = Object.create(PIXI.Container.prototype);\nSpine.prototype.constructor = Spine;\nmodule.exports = Spine;\n\nSpine.globalAutoUpdate = true;\n\nObject.defineProperties(Spine.prototype, {\n    /**\n     * If this flag is set to true, the spine animation will be autoupdated every time\n     * the object id drawn. The down side of this approach is that the delta time is\n     * automatically calculated and you could miss out on cool effects like slow motion,\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n     * autoupdate enabled but are harder to achieve.\n     *\n     * @member {boolean}\n     * @memberof Spine#\n     * @default true\n     */\n    autoUpdate: {\n        get: function ()\n        {\n            return (this.updateTransform === Spine.prototype.autoUpdateTransform);\n        },\n\n        set: function (value)\n        {\n            this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\n        }\n    }\n});\n\n/**\n * Update the spine skeleton and its animations by delta time (dt)\n *\n * @param dt {number} Delta time. Time by which the animation should be updated\n */\nSpine.prototype.update = function (dt)\n{\n    this.state.update(dt);\n    this.state.apply(this.skeleton);\n    this.skeleton.updateWorldTransform();\n\n    var drawOrder = this.skeleton.drawOrder;\n    var slots = this.skeleton.slots;\n\n    for (var i = 0, n = drawOrder.length; i < n; i++)\n    {\n        this.children[i] = this.slotContainers[drawOrder[i]];\n    }\n\n    for (i = 0, n = slots.length; i < n; i++)\n    {\n        var slot = slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = this.slotContainers[i];\n\n        if (!attachment)\n        {\n            slotContainer.visible = false;\n            continue;\n        }\n\n        var type = attachment.type;\n        if (type === spine.AttachmentType.region)\n        {\n            if (attachment.rendererObject)\n            {\n                if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.rendererObject.name)\n                {\n                    var spriteName = attachment.rendererObject.name;\n                    if (slot.currentSprite !== undefined)\n                    {\n                        slot.currentSprite.visible = false;\n                    }\n                    slot.sprites = slot.sprites || {};\n                    if (slot.sprites[spriteName] !== undefined)\n                    {\n                        slot.sprites[spriteName].visible = true;\n                    }\n                    else\n                    {\n                        var sprite = this.createSprite(slot, attachment);\n                        slotContainer.addChild(sprite);\n                    }\n                    slot.currentSprite = slot.sprites[spriteName];\n                    slot.currentSpriteName = spriteName;\n                }\n            }\n\n            if (slotContainer.transform ) {\n                //PIXI v4.0\n                if (!slotContainer.transform._dirtyLocal) {\n                    slotContainer.transform = new PIXI.TransformStatic();\n                }\n                var transform = slotContainer.transform;\n                var lt = transform.localTransform;\n                transform._dirtyParentVersion = -1;\n                transform._dirtyLocal = 1;\n                transform._versionLocal = 1;\n                slot.bone.matrix.copy(lt);\n                lt.tx += slot.bone.skeleton.x;\n                lt.ty += slot.bone.skeleton.y;\n            } else {\n                //PIXI v3\n                var lt = slotContainer.localTransform || new PIXI.Matrix();\n                slot.bone.matrix.copy(lt);\n                lt.tx += slot.bone.skeleton.x;\n                lt.ty += slot.bone.skeleton.y;\n                slotContainer.localTransform = lt;\n                slotContainer.displayObjectUpdateTransform = SlotContainerUpdateTransformV3;\n            }\n\n            slot.currentSprite.blendMode = slot.blendMode;\n            slot.currentSprite.tint = PIXI.utils.rgb2hex([slot.r,slot.g,slot.b]);\n        }\n        else if (type === spine.AttachmentType.skinnedmesh || type === spine.AttachmentType.mesh)\n        {\n            if (!slot.currentMeshName || slot.currentMeshName !== attachment.name)\n            {\n                var meshName = attachment.name;\n                if (slot.currentMesh !== undefined)\n                {\n                    slot.currentMesh.visible = false;\n                }\n\n                slot.meshes = slot.meshes || {};\n\n                if (slot.meshes[meshName] !== undefined)\n                {\n                    slot.meshes[meshName].visible = true;\n                }\n                else\n                {\n                    var mesh = this.createMesh(slot, attachment);\n                    slotContainer.addChild(mesh);\n                }\n\n                slot.currentMesh = slot.meshes[meshName];\n                slot.currentMeshName = meshName;\n            }\n            attachment.computeWorldVertices(slot.bone.skeleton.x, slot.bone.skeleton.y, slot, slot.currentMesh.vertices);\n        }\n        else\n        {\n            slotContainer.visible = false;\n            continue;\n        }\n        slotContainer.visible = true;\n\n        slotContainer.alpha = slot.a;\n    }\n};\n\n/**\n * When autoupdate is set to yes this function is used as pixi's updateTransform function\n *\n * @private\n */\nSpine.prototype.autoUpdateTransform = function ()\n{\n    if (Spine.globalAutoUpdate) {\n        this.lastTime = this.lastTime || Date.now();\n        var timeDelta = (Date.now() - this.lastTime) * 0.001;\n        this.lastTime = Date.now();\n        this.update(timeDelta);\n    } else {\n        this.lastTime = 0;\n    }\n\n    PIXI.Container.prototype.updateTransform.call(this);\n};\n\n/**\n * Create a new sprite to be used with spine.RegionAttachment\n *\n * @param slot {spine.Slot} The slot to which the attachment is parented\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n * @private\n */\nSpine.prototype.createSprite = function (slot, attachment)\n{\n    var descriptor = attachment.rendererObject;\n    var texture = descriptor.texture;\n    var sprite = new PIXI.Sprite(texture);\n    sprite.scale.x = attachment.scaleX * attachment.width / descriptor.originalWidth;\n    sprite.scale.y = - attachment.scaleY * attachment.height / descriptor.originalHeight;\n    sprite.rotation = attachment.rotation * spine.degRad;\n    sprite.anchor.x = 0.5;\n    sprite.anchor.y = 0.5;\n    sprite.position.x = attachment.x;\n    sprite.position.y = attachment.y;\n    sprite.alpha = attachment.a;\n\n    slot.sprites = slot.sprites || {};\n    slot.sprites[descriptor.name] = sprite;\n    return sprite;\n};\n\n/**\n * Creates a Strip from the spine data\n * @param slot {spine.Slot} The slot to which the attachment is parented\n * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n * @private\n */\nSpine.prototype.createMesh = function (slot, attachment)\n{\n    var descriptor = attachment.rendererObject;\n    var baseTexture = descriptor.page.rendererObject;\n    var texture = new PIXI.Texture(baseTexture);\n\n    var strip = new PIXI.mesh.Mesh(\n        texture,\n        new Float32Array(attachment.uvs.length),\n        new Float32Array(attachment.uvs),\n        new Uint16Array(attachment.triangles),\n        PIXI.mesh.Mesh.DRAW_MODES.TRIANGLES);\n\n    strip.canvasPadding = 1.5;\n\n    strip.alpha = attachment.a;\n\n    slot.meshes = slot.meshes || {};\n    slot.meshes[attachment.name] = strip;\n\n    return strip;\n};\n\nfunction SlotContainerUpdateTransformV3()\n{\n    var pt = this.parent.worldTransform;\n    var wt = this.worldTransform;\n    var lt = this.localTransform;\n    wt.a  = lt.a  * pt.a + lt.b  * pt.c;\n    wt.b  = lt.a  * pt.b + lt.b  * pt.d;\n    wt.c  = lt.c  * pt.a + lt.d  * pt.c;\n    wt.d  = lt.c  * pt.b + lt.d  * pt.d;\n    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    this._currentBounds = null;\n};\n","var spine = require('../SpineUtil');\nspine.Animation = function (name, timelines, duration)\n{\n    this.name = name;\n    this.timelines = timelines;\n    this.duration = duration;\n};\nspine.Animation.prototype = {\n    apply: function (skeleton, lastTime, time, loop, events)\n    {\n        if (loop && this.duration != 0)\n        {\n            time %= this.duration;\n            lastTime %= this.duration;\n        }\n        var timelines = this.timelines;\n        for (var i = 0, n = timelines.length; i < n; i++)\n            timelines[i].apply(skeleton, lastTime, time, events, 1);\n    },\n    mix: function (skeleton, lastTime, time, loop, events, alpha)\n    {\n        if (loop && this.duration != 0)\n        {\n            time %= this.duration;\n            lastTime %= this.duration;\n        }\n        var timelines = this.timelines;\n        for (var i = 0, n = timelines.length; i < n; i++)\n            timelines[i].apply(skeleton, lastTime, time, events, alpha);\n    }\n};\nspine.Animation.binarySearch = function (values, target, step)\n{\n    var low = 0;\n    var high = Math.floor(values.length / step) - 2;\n    if (!high) return step;\n    var current = high >>> 1;\n    while (true)\n    {\n        if (values[(current + 1) * step] <= target)\n            low = current + 1;\n        else\n            high = current;\n        if (low == high) return (low + 1) * step;\n        current = (low + high) >>> 1;\n    }\n};\nspine.Animation.binarySearch1 = function (values, target)\n{\n    var low = 0;\n    var high = values.length - 2;\n    if (!high) return 1;\n    var current = high >>> 1;\n    while (true)\n    {\n        if (values[current + 1] <= target)\n            low = current + 1;\n        else\n            high = current;\n        if (low == high) return low + 1;\n        current = (low + high) >>> 1;\n    }\n};\nspine.Animation.linearSearch = function (values, target, step)\n{\n    for (var i = 0, last = values.length - step; i <= last; i += step)\n        if (values[i] > target) return i;\n    return -1;\n};\nmodule.exports = spine.Animation;\n","var spine = require('../SpineUtil');\nspine.TrackEntry = require('./TrackEntry');\nspine.AnimationState = function (stateData)\n{\n    this.data = stateData;\n    this.tracks = [];\n    this.events = [];\n};\nspine.AnimationState.prototype = {\n    onStart: null,\n    onEnd: null,\n    onComplete: null,\n    onEvent: null,\n    timeScale: 1,\n    update: function (delta)\n    {\n        delta *= this.timeScale;\n        for (var i = 0; i < this.tracks.length; i++)\n        {\n            var current = this.tracks[i];\n            if (!current) continue;\n\n            current.time += delta * current.timeScale;\n            if (current.previous)\n            {\n                var previousDelta = delta * current.previous.timeScale;\n                current.previous.time += previousDelta;\n                current.mixTime += previousDelta;\n            }\n\n            var next = current.next;\n            if (next)\n            {\n                next.time = current.lastTime - next.delay;\n                if (next.time >= 0) this.setCurrent(i, next);\n            } else {\n                // End non-looping animation when it reaches its end time and there is no next entry.\n                if (!current.loop && current.lastTime >= current.endTime) this.clearTrack(i);\n            }\n        }\n    },\n    apply: function (skeleton)\n    {\n        skeleton.resetDrawOrder();\n\n        for (var i = 0; i < this.tracks.length; i++)\n        {\n            var current = this.tracks[i];\n            if (!current) continue;\n\n            this.events.length = 0;\n\n            var time = current.time;\n            var lastTime = current.lastTime;\n            var endTime = current.endTime;\n            var loop = current.loop;\n            if (!loop && time > endTime) time = endTime;\n\n            var previous = current.previous;\n            if (!previous)\n            {\n                if (current.mix == 1)\n                    current.animation.apply(skeleton, current.lastTime, time, loop, this.events);\n                else\n                    current.animation.mix(skeleton, current.lastTime, time, loop, this.events, current.mix);\n            } else {\n                var previousTime = previous.time;\n                if (!previous.loop && previousTime > previous.endTime) previousTime = previous.endTime;\n                previous.animation.apply(skeleton, previousTime, previousTime, previous.loop, null);\n\n                var alpha = current.mixTime / current.mixDuration * current.mix;\n                if (alpha >= 1)\n                {\n                    alpha = 1;\n                    current.previous = null;\n                }\n                current.animation.mix(skeleton, current.lastTime, time, loop, this.events, alpha);\n            }\n\n            for (var ii = 0, nn = this.events.length; ii < nn; ii++)\n            {\n                var event = this.events[ii];\n                if (current.onEvent) current.onEvent(i, event);\n                if (this.onEvent) this.onEvent(i, event);\n            }\n\n            // Check if completed the animation or a loop iteration.\n            if (loop ? (lastTime % endTime > time % endTime) : (lastTime < endTime && time >= endTime))\n            {\n                var count = Math.floor(time / endTime);\n                if (current.onComplete) current.onComplete(i, count);\n                if (this.onComplete) this.onComplete(i, count);\n            }\n\n            current.lastTime = current.time;\n        }\n    },\n    clearTracks: function ()\n    {\n        for (var i = 0, n = this.tracks.length; i < n; i++)\n            this.clearTrack(i);\n        this.tracks.length = 0;\n    },\n    clearTrack: function (trackIndex)\n    {\n        if (trackIndex >= this.tracks.length) return;\n        var current = this.tracks[trackIndex];\n        if (!current) return;\n\n        if (current.onEnd) current.onEnd(trackIndex);\n        if (this.onEnd) this.onEnd(trackIndex);\n\n        this.tracks[trackIndex] = null;\n    },\n    _expandToIndex: function (index)\n    {\n        if (index < this.tracks.length) return this.tracks[index];\n        while (index >= this.tracks.length)\n            this.tracks.push(null);\n        return null;\n    },\n    setCurrent: function (index, entry)\n    {\n        var current = this._expandToIndex(index);\n        if (current)\n        {\n            var previous = current.previous;\n            current.previous = null;\n\n            if (current.onEnd) current.onEnd(index);\n            if (this.onEnd) this.onEnd(index);\n\n            entry.mixDuration = this.data.getMix(current.animation, entry.animation);\n            if (entry.mixDuration > 0)\n            {\n                entry.mixTime = 0;\n                // If a mix is in progress, mix from the closest animation.\n                if (previous && current.mixTime / current.mixDuration < 0.5)\n                    entry.previous = previous;\n                else\n                    entry.previous = current;\n            }\n        }\n\n        this.tracks[index] = entry;\n\n        if (entry.onStart) entry.onStart(index);\n        if (this.onStart) this.onStart(index);\n    },\n    setAnimationByName: function (trackIndex, animationName, loop)\n    {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        if (!animation) throw \"Animation not found: \" + animationName;\n        return this.setAnimation(trackIndex, animation, loop);\n    },\n    /** Set the current animation. Any queued animations are cleared. */\n    setAnimation: function (trackIndex, animation, loop)\n    {\n        var entry = new spine.TrackEntry();\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.endTime = animation.duration;\n        this.setCurrent(trackIndex, entry);\n        return entry;\n    },\n    addAnimationByName: function (trackIndex, animationName, loop, delay)\n    {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        if (!animation) throw \"Animation not found: \" + animationName;\n        return this.addAnimation(trackIndex, animation, loop, delay);\n    },\n    /** Adds an animation to be played delay seconds after the current or last queued animation.\n     * @param delay May be <= 0 to use duration of previous animation minus any mix duration plus the negative delay. */\n    addAnimation: function (trackIndex, animation, loop, delay)\n    {\n        var entry = new spine.TrackEntry();\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.endTime = animation.duration;\n\n        var last = this._expandToIndex(trackIndex);\n        if (last)\n        {\n            while (last.next)\n                last = last.next;\n            last.next = entry;\n        } else\n            this.tracks[trackIndex] = entry;\n\n        if (delay <= 0)\n        {\n            if (last)\n                delay += last.endTime - this.data.getMix(last.animation, animation);\n            else\n                delay = 0;\n        }\n        entry.delay = delay;\n\n        return entry;\n    },\n    /**\n     * Returns true if animation exists in skeleton data\n     * @param animationName\n     * @returns {boolean}\n     */\n    hasAnimationByName: function (animationName)\n    {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        return animation !== null;\n    },\n    /** May be null. */\n    getCurrent: function (trackIndex)\n    {\n        if (trackIndex >= this.tracks.length) return null;\n        return this.tracks[trackIndex];\n    }\n};\nmodule.exports = spine.AnimationState;\n\n","var spine = require('../SpineUtil');\nspine.AnimationStateData = function (skeletonData)\n{\n    this.skeletonData = skeletonData;\n    this.animationToMixTime = {};\n};\nspine.AnimationStateData.prototype = {\n    defaultMix: 0,\n    setMixByName: function (fromName, toName, duration)\n    {\n        var from = this.skeletonData.findAnimation(fromName);\n        if (!from) throw \"Animation not found: \" + fromName;\n        var to = this.skeletonData.findAnimation(toName);\n        if (!to) throw \"Animation not found: \" + toName;\n        this.setMix(from, to, duration);\n    },\n    setMix: function (from, to, duration)\n    {\n        this.animationToMixTime[from.name + \":\" + to.name] = duration;\n    },\n    getMix: function (from, to)\n    {\n        var key = from.name + \":\" + to.name;\n        return this.animationToMixTime.hasOwnProperty(key) ? this.animationToMixTime[key] : this.defaultMix;\n    }\n};\nmodule.exports = spine.AnimationStateData;\n\n","var spine = require('../SpineUtil');\nspine.AtlasReader = require('./AtlasReader');\nspine.AtlasPage = require('./AtlasPage');\nspine.AtlasRegion = require('./AtlasRegion');\nvar syncImageLoaderAdapter = require('../loaders/syncImageLoaderAdapter.js')\n\nspine.Atlas = function(atlasText, loaderFunction, callback) {\n    this.pages = [];\n    this.regions = [];\n    if (typeof atlasText === \"string\") {\n        this.addSpineAtlas.call(this, atlasText, loaderFunction, callback);\n    }\n};\n\nspine.Atlas.prototype = {\n    addTexture: function(name, texture) {\n        var pages = this.pages;\n        var page = null;\n        for (var i=0;i<pages.length;i++) {\n            if (pages[i].rendererObject === texture.baseTexture) {\n                page = pages[i];\n                break;\n            }\n        }\n        if (page === null) {\n            page = new spine.AtlasPage();\n            page.name = 'texturePage';\n            var baseTexture = texture.baseTexture;\n            page.width = baseTexture.realWidth;\n            page.height = baseTexture.realHeight;\n            page.rendererObject = baseTexture;\n            //those fields are not relevant in Pixi\n            page.format = 'RGBA8888';\n            page.minFilter = page.magFilter = \"Nearest\";\n            page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\n            page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\n            pages.push(page);\n        }\n        var region = new spine.AtlasRegion();\n        region.name = name;\n        region.page = page;\n        region.texture = texture;\n        region.index = -1;\n        this.regions.push(region);\n        return region;\n    },\n    addTextureHash: function(textures, stripExtension) {\n        for (var key in textures) {\n            if (textures.hasOwnProperty(key)) {\n                this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\n            }\n        }\n    },\n    addSpineAtlas: function (atlasText, loaderFunction, callback)\n    {\n        //TODO: remove this legacy later\n        if (typeof loaderFunction !== \"function\") {\n            //old syntax\n            var baseUrl = loaderFunction;\n            var crossOrigin = callback;\n            loaderFunction = syncImageLoaderAdapter(baseUrl, crossOrigin);\n            callback = null;\n        }\n\n        this.texturesLoading = 0;\n\n        var self = this;\n\n        var reader = new spine.AtlasReader(atlasText);\n        var tuple = [];\n        tuple.length = 4;\n        var page = null;\n\n        iterateParser();\n\n        function iterateParser() {\n            while (true) {\n                var line = reader.readLine();\n                if (line === null) {\n                    return callback && callback(self);\n                }\n                line = reader.trim(line);\n                if (!line.length)\n                    page = null;\n                else if (!page) {\n                    page = new spine.AtlasPage();\n                    page.name = line;\n\n                    if (reader.readTuple(tuple) == 2) { // size is only optional for an atlas packed with an old TexturePacker.\n                        page.width = parseInt(tuple[0]);\n                        page.height = parseInt(tuple[1]);\n                        reader.readTuple(tuple);\n                    } else {\n                        //old format, detect width and height by texture\n                    }\n                    page.format = spine.Atlas.Format[tuple[0]];\n\n                    reader.readTuple(tuple);\n                    page.minFilter = spine.Atlas.TextureFilter[tuple[0]];\n                    page.magFilter = spine.Atlas.TextureFilter[tuple[1]];\n\n                    var direction = reader.readValue();\n                    page.uWrap = spine.Atlas.TextureWrap.clampToEdge;\n                    page.vWrap = spine.Atlas.TextureWrap.clampToEdge;\n                    if (direction == \"x\")\n                        page.uWrap = spine.Atlas.TextureWrap.repeat;\n                    else if (direction == \"y\")\n                        page.vWrap = spine.Atlas.TextureWrap.repeat;\n                    else if (direction == \"xy\")\n                        page.uWrap = page.vWrap = spine.Atlas.TextureWrap.repeat;\n\n                    // @ivanpopelyshev: I so want to use generators and \"yield()\" here, or at least promises\n                    loaderFunction(line, function (texture) {\n                        page.rendererObject = texture;\n                        if (!texture.hasLoaded) {\n                            texture.width = page.width;\n                            texture.height = page.height;\n                        }\n                        self.pages.push(page);\n                        if (!page.width || !page.height) {\n                            page.width = texture.realWidth;\n                            page.height = texture.realHeight;\n                            if (!page.width || !page.height) {\n                                console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\n                            }\n                        }\n                        iterateParser();\n                    });\n                    break;\n                } else {\n                    var region = new spine.AtlasRegion();\n                    region.name = line;\n                    region.page = page;\n\n                    var rotate = reader.readValue() === \"true\" ? 6 : 0;\n\n                    reader.readTuple(tuple);\n                    var x = parseInt(tuple[0]);\n                    var y = parseInt(tuple[1]);\n\n                    reader.readTuple(tuple);\n                    var width = parseInt(tuple[0]);\n                    var height = parseInt(tuple[1]);\n\n                    var resolution = page.rendererObject.resolution;\n                    x /= resolution;\n                    y /= resolution;\n                    width /= resolution;\n                    height /= resolution;\n\n                    var frame = new PIXI.Rectangle(x, y, rotate ? height : width, rotate ? width : height);\n\n                    if (reader.readTuple(tuple) == 4) { // split is optional\n                        region.splits = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\n\n                        if (reader.readTuple(tuple) == 4) { // pad is optional, but only present with splits\n                            region.pads = [parseInt(tuple[0]), parseInt(tuple[1]), parseInt(tuple[2]), parseInt(tuple[3])];\n\n                            reader.readTuple(tuple);\n                        }\n                    }\n\n                    var originalWidth = parseInt(tuple[0]) / resolution;\n                    var originalHeight = parseInt(tuple[1]) / resolution;\n                    reader.readTuple(tuple);\n                    var offsetX = parseInt(tuple[0]) / resolution;\n                    var offsetY = parseInt(tuple[1]) / resolution;\n\n                    var orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\n                    var trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\n\n                    //TODO: pixiv3 uses different frame/crop/trim\n\n                    if (PIXI.VERSION[0] == '4') {\n                        // pixi v4.0.0\n                        region.texture = new PIXI.Texture(region.page.rendererObject, frame, orig, trim, rotate);\n                    } else {\n                        // pixi v3.0.11\n                        var frame2 = new PIXI.Rectangle(x, y, width, height);\n                        var crop = frame2.clone();\n                        trim.width = originalWidth;\n                        trim.height = originalHeight;\n                        region.texture = new PIXI.Texture(region.page.rendererObject, frame2, crop, trim, rotate);\n                    }\n\n                    region.index = parseInt(reader.readValue());\n                    region.texture._updateUvs();\n\n                    self.regions.push(region);\n                }\n            }\n        }\n    },\n    findRegion: function (name)\n    {\n        var regions = this.regions;\n        for (var i = 0, n = regions.length; i < n; i++)\n            if (regions[i].name == name) return regions[i];\n        return null;\n    },\n    dispose: function ()\n    {\n        var pages = this.pages;\n        for (var i = 0, n = pages.length; i < n; i++)\n            pages[i].rendererObject.destroy(true);\n    },\n    updateUVs: function (page)\n    {\n        var regions = this.regions;\n        for (var i = 0, n = regions.length; i < n; i++)\n        {\n            var region = regions[i];\n            if (region.page != page) continue;\n            region.texture._updateUvs();\n        }\n    }\n};\n\nspine.Atlas.Format = {\n    alpha: 0,\n    intensity: 1,\n    luminanceAlpha: 2,\n    rgb565: 3,\n    rgba4444: 4,\n    rgb888: 5,\n    rgba8888: 6\n};\n\nspine.Atlas.TextureFilter = {\n    nearest: 0,\n    linear: 1,\n    mipMap: 2,\n    mipMapNearestNearest: 3,\n    mipMapLinearNearest: 4,\n    mipMapNearestLinear: 5,\n    mipMapLinearLinear: 6\n};\n\nspine.Atlas.TextureWrap = {\n    mirroredRepeat: 0,\n    clampToEdge: 1,\n    repeat: 2\n};\nmodule.exports = spine.Atlas;\n","var spine = require('../SpineUtil');\nspine.RegionAttachment = require('./RegionAttachment');\nspine.MeshAttachment = require('./MeshAttachment');\nspine.WeightedMeshAttachment = require('./WeightedMeshAttachment');\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\nspine.AtlasAttachmentParser = function (atlas)\n{\n    this.atlas = atlas;\n};\nspine.AtlasAttachmentParser.prototype = {\n    newRegionAttachment: function (skin, name, path)\n    {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\";\n        var attachment = new spine.RegionAttachment(name);\n        attachment.rendererObject = region;\n        attachment.setUVs(region.u, region.v, region.u2, region.v2, region.rotate);\n        attachment.regionOffsetX = region.offsetX;\n        attachment.regionOffsetY = region.spineOffsetY;\n        attachment.regionWidth = region.width;\n        attachment.regionHeight = region.height;\n        attachment.regionOriginalWidth = region.originalWidth;\n        attachment.regionOriginalHeight = region.originalHeight;\n        return attachment;\n    },\n    newMeshAttachment: function (skin, name, path)\n    {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\";\n        var attachment = new spine.MeshAttachment(name);\n        attachment.rendererObject = region;\n        // region.texture.on('update', spine.MeshAttachment.prototype.updateUVs.bind(attachment));\n        return attachment;\n    },\n    newWeightedMeshAttachment: function (skin, name, path)\n    {\n        var region = this.atlas.findRegion(path);\n        if (!region) throw \"Region not found in atlas: \" + path + \" (skinned mesh attachment: \" + name + \")\";\n        var attachment = new spine.WeightedMeshAttachment(name);\n        attachment.rendererObject = region;\n        // region.texture.on('update', spine.WeightedMeshAttachment.prototype.updateUVs.bind(attachment));\n        return attachment;\n    },\n    newBoundingBoxAttachment: function (skin, name)\n    {\n        return new spine.BoundingBoxAttachment(name);\n    }\n};\nmodule.exports = spine.AtlasAttachmentParser;\n\n","var spine = require('../SpineUtil');\nspine.AtlasPage = function ()\n{};\nspine.AtlasPage.prototype = {\n    name: null,\n    format: null,\n    minFilter: null,\n    magFilter: null,\n    uWrap: null,\n    vWrap: null,\n    rendererObject: null,\n    width: 0,\n    height: 0\n};\nmodule.exports = spine.AtlasPage;\n\n","var spine = require('../SpineUtil');\nspine.AtlasReader = function (text)\n{\n    this.lines = text.split(/\\r\\n|\\r|\\n/);\n};\nspine.AtlasReader.prototype = {\n    index: 0,\n    trim: function (value)\n    {\n        return value.replace(/^\\s+|\\s+$/g, \"\");\n    },\n    readLine: function ()\n    {\n        if (this.index >= this.lines.length) return null;\n        return this.lines[this.index++];\n    },\n    readValue: function ()\n    {\n        var line = this.readLine();\n        var colon = line.indexOf(\":\");\n        if (colon == -1) throw \"Invalid line: \" + line;\n        return this.trim(line.substring(colon + 1));\n    },\n    /** Returns the number of tuple values read (1, 2 or 4). */\n    readTuple: function (tuple)\n    {\n        var line = this.readLine();\n        var colon = line.indexOf(\":\");\n        if (colon == -1) throw \"Invalid line: \" + line;\n        var i = 0, lastMatch = colon + 1;\n        for (; i < 3; i++)\n        {\n            var comma = line.indexOf(\",\", lastMatch);\n            if (comma == -1) break;\n            tuple[i] = this.trim(line.substr(lastMatch, comma - lastMatch));\n            lastMatch = comma + 1;\n        }\n        tuple[i] = this.trim(line.substring(lastMatch));\n        return i + 1;\n    }\n};\nmodule.exports = spine.AtlasReader;\n\n","var spine = require('../SpineUtil');\nspine.AtlasRegion = function ()\n{};\nspine.AtlasRegion.prototype = {\n    name: null,\n    /**\n     * @member {PIXI.Texture}\n     */\n    texture: null,\n\n    /**\n     * @member {PIXI.spine.Spine.AtlasPage}\n     */\n    page: null,\n    index: 0,\n    splits: null,\n    pads: null\n};\n\nObject.defineProperties(spine.AtlasRegion.prototype, {\n    x: {\n        get: function() {\n            return this.texture.frame.x;\n        }\n    },\n    y: {\n        get: function() {\n            return this.texture.frame.y;\n        }\n    },\n    width: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                return tex.crop.width;\n            }\n            if (tex.trim) {\n                return tex.trim.width;\n            }\n            return tex.orig.width;\n        }\n    },\n    height: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                return tex.crop.height;\n            }\n            if (tex.trim) {\n                return tex.trim.height;\n            }\n            return tex.orig.height;\n        }\n    },\n    u: {\n        get: function() {\n            return this.texture._uvs.x0;\n        }\n    },\n    v: {\n        get: function() {\n            return this.texture._uvs.y0;\n        }\n    },\n    u2: {\n        get: function() {\n            return this.texture._uvs.x2;\n        }\n    },\n    v2: {\n        get: function() {\n            return this.texture._uvs.y2;\n        }\n    },\n    rotate: {\n        get: function() {\n            return !!this.texture.rotate;\n        }\n    },\n    offsetX: {\n        get: function() {\n            var tex = this.texture;\n            return tex.trim ? tex.trim.x : 0;\n        }\n    },\n    offsetY: {\n        get: function() {\n            console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\n            return this.spineOffsetY;\n        }\n    },\n    pixiOffsetY: {\n        get: function() {\n            var tex = this.texture;\n            return tex.trim ? tex.trim.y : 0;\n        }\n    },\n    spineOffsetY: {\n        get: function() {\n            var tex = this.texture;\n            return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\n        }\n    },\n    originalWidth: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                if (tex.trim) {\n                    return tex.trim.width;\n                }\n                return tex.crop.width;\n            }\n            return tex.orig.width;\n        }\n    },\n    originalHeight: {\n        get: function() {\n            var tex = this.texture;\n            if (PIXI.VERSION[0] == '3') {\n                if (tex.trim) {\n                    return tex.trim.height;\n                }\n                return tex.crop.height;\n            }\n            return tex.orig.height;\n        }\n    }\n});\n\nmodule.exports = spine.AtlasRegion;\n\n","var spine = require('../SpineUtil');\nspine.Curves = require('./Curves');\nspine.Animation = require('./Animation');\nspine.AttachmentTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, ...\n    this.frames.length = frameCount;\n    this.attachmentNames = [];\n    this.attachmentNames.length = frameCount;\n};\nspine.AttachmentTimeline.prototype = {\n    slotIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length;\n    },\n    setFrame: function (frameIndex, time, attachmentName)\n    {\n        this.frames[frameIndex] = time;\n        this.attachmentNames[frameIndex] = attachmentName;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0])\n        {\n            if (lastTime > time) this.apply(skeleton, lastTime, Number.MAX_VALUE, null, 0);\n            return;\n        } else if (lastTime > time) //\n            lastTime = -1;\n\n        var frameIndex = time >= frames[frames.length - 1] ? frames.length - 1 : spine.Animation.binarySearch1(frames, time) - 1;\n        if (frames[frameIndex] < lastTime) return;\n\n        var attachmentName = this.attachmentNames[frameIndex];\n        skeleton.slots[this.slotIndex].setAttachment(\n            !attachmentName ? null : skeleton.getAttachmentBySlotIndex(this.slotIndex, attachmentName));\n    }\n};\nmodule.exports = spine.AttachmentTimeline;\n\n","var spine = require('../SpineUtil');\nspine.AttachmentType = {\n    region: 0,\n    boundingbox: 1,\n    mesh: 2,\n    weightedmesh : 3,\n    skinnedmesh: 3,\n    linkedmesh: 4,\n    weightedlinkedmesh: 5\n};\nmodule.exports = spine.AttachmentType;\n\n","var spine = require('../SpineUtil');\nspine.Bone = function (boneData, skeleton, parent)\n{\n    this.data = boneData;\n    this.skeleton = skeleton;\n    this.parent = parent;\n    this.matrix = new PIXI.Matrix();\n    this.setToSetupPose();\n};\nspine.Bone.yDown = false;\nspine.Bone.prototype = {\n    x: 0, y: 0,\n    rotation: 0, rotationIK: 0,\n    scaleX: 1, scaleY: 1,\n    shearX: 0, shearY: 0,\n    flipX: false, flipY: false,\n\n    worldSignX: 1, worldSignY: 1,\n    update: function() {\n        this.rotationIK = this.rotation;\n        this.updateWorldTransform();\n    },\n    updateWorldTransform: function() {\n        var rotation = this.rotationIK;\n        var scaleX = this.scaleX;\n        var scaleY = this.scaleY;\n        var x = this.x;\n        var y = this.y;\n        var rotationX = rotation + this.shearX;\n        var rotationY = rotation + 90 + this.shearY;\n\n        var la = Math.cos(rotationX * spine.degRad) * scaleX, lb = Math.cos(rotationY * spine.degRad) * scaleY,\n            lc = Math.sin(rotationX * spine.degRad) * scaleX, ld = Math.sin(rotationY * spine.degRad) * scaleY;\n        var parent = this.parent;\n        var m = this.matrix;\n        var skeleton = this.skeleton;\n        if (!parent) { // Root bone.\n            if (skeleton.flipX) {\n                x = -x;\n                la = -la;\n                lb = -lb;\n            }\n            if (skeleton.flipY !== spine.Bone.yDown) {\n                y = -y;\n                lc = -lc;\n                ld = -ld;\n            }\n            m.a = la;\n            m.c = lb;\n            m.b = lc;\n            m.d = ld;\n            m.tx = x;\n            m.ty = y;\n            this.worldSignX = spine.signum(scaleX);\n            this.worldSignY = spine.signum(scaleY);\n            return;\n        }\n\n\n        var pa = parent.matrix.a, pb = parent.matrix.c, pc = parent.matrix.b, pd = parent.matrix.d;\n        m.tx = pa * x + pb * y + parent.matrix.tx;\n        m.ty = pc * x + pd * y + parent.matrix.ty;\n        this.worldSignX = parent.worldSignX * spine.signum(scaleX);\n        this.worldSignY = parent.worldSignY * spine.signum(scaleY);\n        var data = this.data;\n\n        if (data.inheritRotation && data.inheritScale) {\n            m.a = pa * la + pb * lc;\n            m.c = pa * lb + pb * ld;\n            m.b = pc * la + pd * lc;\n            m.d = pc * lb + pd * ld;\n        } else {\n            if (data.inheritRotation) { // No scale inheritance.\n                pa = 1;\n                pb = 0;\n                pc = 0;\n                pd = 1;\n                do {\n                    cos = Math.cos(parent.rotationIK * spine.degRad);\n                    sin = Math.sin(parent.rotationIK * spine.degRad);\n                    var temp = pa * cos + pb * sin;\n                    pb = pa * -sin + pb * cos;\n                    pa = temp;\n                    temp = pc * cos + pd * sin;\n                    pd = pc * -sin + pd * cos;\n                    pc = temp;\n\n                    if (!parent.data.inheritRotation) break;\n                    parent = parent.parent;\n                } while (parent != null);\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n            } else if (data.inheritScale) { // No rotation inheritance.\n                pa = 1;\n                pb = 0;\n                pc = 0;\n                pd = 1;\n                do {\n                    var r = parent.rotationIK;\n                    cos = Math.cos(r * spine.degRad);\n                    sin = Math.sin(r * spine.degRad);\n                    var psx = parent.scaleX, psy = parent.scaleY;\n                    var za = cos * psx, zb = -sin * psy, zc = sin * psx, zd = cos * psy;\n                    temp = pa * za + pb * zc;\n                    pb = pa * zb + pb * zd;\n                    pa = temp;\n                    temp = pc * za + pd * zc;\n                    pd = pc * zb + pd * zd;\n                    pc = temp;\n\n                    if (psx < 0) {\n                        r = -r;\n                    } else {\n                        sin = -sin;\n                    }\n                    temp = pa * cos + pb * sin;\n                    pb = pa * -sin + pb * cos;\n                    pa = temp;\n                    temp = pc * cos + pd * sin;\n                    pd = pc * -sin + pd * cos;\n                    pc = temp;\n\n                    if (!parent.data.inheritScale) break;\n                    parent = parent.parent;\n                } while (parent != null);\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n            } else {\n                m.a = la;\n                m.c = lb;\n                m.b = lc;\n                m.d = ld;\n            }\n            if (skeleton.flipX) {\n                m.a = -m.a;\n                m.c = -m.c;\n            }\n            if (skeleton.flipY !== spine.Bone.yDown) {\n                m.b = -m.b;\n                m.d = -m.d;\n            }\n        }\n    },\n\n    setToSetupPose: function ()\n    {\n        var data = this.data;\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.rotationIK = this.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n        this.shearX = data.shearX;\n        this.shearY = data.shearY;\n    },\n    worldToLocal: function (world)\n    {\n        var m = this.matrix;\n        var dx = world[0] - m.tx, dy = m.ty;\n        var invDet = 1 / (m.a * m.d - m.b * m.c);\n        //Yep, its a bug in original spine. I hope they'll fix it: https://github.com/EsotericSoftware/spine-runtimes/issues/544\n        world[0] = dx * m.a * invDet - dy * m.c * invDet;\n        world[1] = dy * m.d * invDet - dx * m.b * invDet;\n    },\n    localToWorld: function (local)\n    {\n        var localX = local[0], localY = local[1];\n        var m = this.matrix;\n        local[0] = localX * m.a + localY * m.c + m.tx;\n        local[1] = localX * m.b + localY * m.d + m.ty;\n    },\n    getWorldRotationX: function() {\n        return Math.atan2(this.matrix.b, this.matrix.a) * spine.radDeg;\n\n    },\n    getWorldRotationY: function() {\n        return Math.atan2(this.matrix.d, this.matrix.c) * spine.radDeg;\n    },\n    getWorldScaleX: function() {\n        var a = this.matrix.a;\n        var b = this.matrix.b;\n        return Math.sqrt(a*a+b*b);\n    },\n    getWorldScaleY: function() {\n        var c = this.matrix.c;\n        var d = this.matrix.d;\n        return Math.sqrt(c * c + d * d);\n    }\n};\n\nObject.defineProperties(spine.Bone.prototype, {\n    worldX: {\n        get: function() {\n            return this.matrix.tx;\n        }\n    },\n    worldY:  {\n        get: function() {\n            return this.matrix.ty;\n        }\n    }\n});\n\nmodule.exports = spine.Bone;\n","var spine = require('../SpineUtil');\nspine.BoneData = function (name, parent)\n{\n    this.name = name;\n    this.parent = parent;\n};\nspine.BoneData.prototype = {\n    length: 0,\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1,\n    shearX: 0, shearY: 0,\n    inheritScale: true,\n    inheritRotation: true\n};\nmodule.exports = spine.BoneData;\n\n","var spine = require('../SpineUtil');\nspine.AttachmentType = require('./AttachmentType');\nspine.BoundingBoxAttachment = function (name)\n{\n    this.name = name;\n    this.vertices = [];\n};\nspine.BoundingBoxAttachment.prototype = {\n    type: spine.AttachmentType.boundingbox,\n    computeWorldVertices: function (x, y, bone, worldVertices)\n    {\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\n        var vertices = this.vertices;\n        for (var i = 0, n = vertices.length; i < n; i += 2)\n        {\n            var px = vertices[i];\n            var py = vertices[i + 1];\n            worldVertices[i] = px * m00 + py * m01 + x;\n            worldVertices[i + 1] = px * m10 + py * m11 + y;\n        }\n    }\n};\nmodule.exports = spine.BoundingBoxAttachment;\n\n","var spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.ColorTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, r, g, b, a, ...\n    this.frames.length = frameCount * 5;\n};\nspine.ColorTimeline.prototype = {\n    slotIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length / 5;\n    },\n    setFrame: function (frameIndex, time, r, g, b, a)\n    {\n        frameIndex *= 5;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = r;\n        this.frames[frameIndex + 2] = g;\n        this.frames[frameIndex + 3] = b;\n        this.frames[frameIndex + 4] = a;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var r, g, b, a;\n        if (time >= frames[frames.length - 5])\n        {\n            // Time is after last frame.\n            var i = frames.length - 1;\n            r = frames[i - 3];\n            g = frames[i - 2];\n            b = frames[i - 1];\n            a = frames[i];\n        } else {\n            // Interpolate between the previous frame and the current frame.\n            var frameIndex = spine.Animation.binarySearch(frames, time, 5);\n            var prevFrameR = frames[frameIndex - 4];\n            var prevFrameG = frames[frameIndex - 3];\n            var prevFrameB = frames[frameIndex - 2];\n            var prevFrameA = frames[frameIndex - 1];\n            var frameTime = frames[frameIndex];\n            var percent = 1 - (time - frameTime) / (frames[frameIndex - 5/*PREV_FRAME_TIME*/] - frameTime);\n            percent = this.curves.getCurvePercent(frameIndex / 5 - 1, percent);\n\n            r = prevFrameR + (frames[frameIndex + 1/*FRAME_R*/] - prevFrameR) * percent;\n            g = prevFrameG + (frames[frameIndex + 2/*FRAME_G*/] - prevFrameG) * percent;\n            b = prevFrameB + (frames[frameIndex + 3/*FRAME_B*/] - prevFrameB) * percent;\n            a = prevFrameA + (frames[frameIndex + 4/*FRAME_A*/] - prevFrameA) * percent;\n        }\n        var slot = skeleton.slots[this.slotIndex];\n        if (alpha < 1)\n        {\n            slot.r += (r - slot.r) * alpha;\n            slot.g += (g - slot.g) * alpha;\n            slot.b += (b - slot.b) * alpha;\n            slot.a += (a - slot.a) * alpha;\n        } else {\n            slot.r = r;\n            slot.g = g;\n            slot.b = b;\n            slot.a = a;\n        }\n    }\n};\nmodule.exports = spine.ColorTimeline;\n\n","var spine = require('../SpineUtil');\nspine.Curves = function (frameCount)\n{\n    this.curves = []; // type, x, y, ...\n    //this.curves.length = (frameCount - 1) * 19/*BEZIER_SIZE*/;\n};\nspine.Curves.prototype = {\n    setLinear: function (frameIndex)\n    {\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 0/*LINEAR*/;\n    },\n    setStepped: function (frameIndex)\n    {\n        this.curves[frameIndex * 19/*BEZIER_SIZE*/] = 1/*STEPPED*/;\n    },\n    /** Sets the control handle positions for an interpolation bezier curve used to transition from this keyframe to the next.\n     * cx1 and cx2 are from 0 to 1, representing the percent of time between the two keyframes. cy1 and cy2 are the percent of\n     * the difference between the keyframe's values. */\n    setCurve: function (frameIndex, cx1, cy1, cx2, cy2)\n    {\n        var subdiv1 = 1 / 10/*BEZIER_SEGMENTS*/, subdiv2 = subdiv1 * subdiv1, subdiv3 = subdiv2 * subdiv1;\n        var pre1 = 3 * subdiv1, pre2 = 3 * subdiv2, pre4 = 6 * subdiv2, pre5 = 6 * subdiv3;\n        var tmp1x = -cx1 * 2 + cx2, tmp1y = -cy1 * 2 + cy2, tmp2x = (cx1 - cx2) * 3 + 1, tmp2y = (cy1 - cy2) * 3 + 1;\n        var dfx = cx1 * pre1 + tmp1x * pre2 + tmp2x * subdiv3, dfy = cy1 * pre1 + tmp1y * pre2 + tmp2y * subdiv3;\n        var ddfx = tmp1x * pre4 + tmp2x * pre5, ddfy = tmp1y * pre4 + tmp2y * pre5;\n        var dddfx = tmp2x * pre5, dddfy = tmp2y * pre5;\n\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\n        var curves = this.curves;\n        curves[i++] = 2/*BEZIER*/;\n\n        var x = dfx, y = dfy;\n        for (var n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\n        {\n            curves[i] = x;\n            curves[i + 1] = y;\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            x += dfx;\n            y += dfy;\n        }\n    },\n    getCurvePercent: function (frameIndex, percent)\n    {\n        percent = percent < 0 ? 0 : (percent > 1 ? 1 : percent);\n        var curves = this.curves;\n        var i = frameIndex * 19/*BEZIER_SIZE*/;\n        var type = curves[i];\n        if (type === 0/*LINEAR*/) return percent;\n        if (type == 1/*STEPPED*/) return 0;\n        i++;\n        var x = 0;\n        for (var start = i, n = i + 19/*BEZIER_SIZE*/ - 1; i < n; i += 2)\n        {\n            x = curves[i];\n            if (x >= percent)\n            {\n                var prevX, prevY;\n                if (i == start)\n                {\n                    prevX = 0;\n                    prevY = 0;\n                } else {\n                    prevX = curves[i - 2];\n                    prevY = curves[i - 1];\n                }\n                return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\n            }\n        }\n        var y = curves[i - 1];\n        return y + (1 - y) * (percent - x) / (1 - x); // Last point is 1,1.\n    }\n};\nmodule.exports = spine.Curves;\n\n","var spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.DrawOrderTimeline = function (frameCount)\n{\n    this.frames = []; // time, ...\n    this.frames.length = frameCount;\n    this.drawOrders = [];\n    this.drawOrders.length = frameCount;\n};\nspine.DrawOrderTimeline.prototype = {\n    getFrameCount: function ()\n    {\n        return this.frames.length;\n    },\n    setFrame: function (frameIndex, time, drawOrder)\n    {\n        this.frames[frameIndex] = time;\n        this.drawOrders[frameIndex] = drawOrder;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var frameIndex;\n        if (time >= frames[frames.length - 1]) // Time is after last frame.\n            frameIndex = frames.length - 1;\n        else\n            frameIndex = spine.Animation.binarySearch1(frames, time) - 1;\n\n        var drawOrder = skeleton.drawOrder;\n        var slots = skeleton.slots;\n        var drawOrderToSetupIndex = this.drawOrders[frameIndex];\n        if (drawOrderToSetupIndex)\n        {\n            for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++)\n            {\n                drawOrder[i] = drawOrderToSetupIndex[i];\n            }\n        }\n\n    }\n};\nmodule.exports = spine.DrawOrderTimeline;\n\n","var spine = require('../SpineUtil');\nspine.Event = function (data)\n{\n    this.data = data;\n};\nspine.Event.prototype = {\n    intValue: 0,\n    floatValue: 0,\n    stringValue: null\n};\nmodule.exports = spine.Event;\n\n","var spine = require('../SpineUtil');\nspine.EventData = function (name)\n{\n    this.name = name;\n};\nspine.EventData.prototype = {\n    intValue: 0,\n    floatValue: 0,\n    stringValue: null\n};\nmodule.exports = spine.EventData;\n\n","var spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.EventTimeline = function (frameCount)\n{\n    this.frames = []; // time, ...\n    this.frames.length = frameCount;\n    this.events = [];\n    this.events.length = frameCount;\n};\nspine.EventTimeline.prototype = {\n    getFrameCount: function ()\n    {\n        return this.frames.length;\n    },\n    setFrame: function (frameIndex, time, event)\n    {\n        this.frames[frameIndex] = time;\n        this.events[frameIndex] = event;\n    },\n    /** Fires events for frames > lastTime and <= time. */\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        if (!firedEvents) return;\n\n        var frames = this.frames;\n        var frameCount = frames.length;\n\n        if (lastTime > time)\n        { // Fire events after last time for looped animations.\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha);\n            lastTime = -1;\n        } else if (lastTime >= frames[frameCount - 1]) // Last time is after last frame.\n            return;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var frameIndex;\n        if (lastTime < frames[0])\n            frameIndex = 0;\n        else\n        {\n            frameIndex = spine.Animation.binarySearch1(frames, lastTime);\n            var frame = frames[frameIndex];\n            while (frameIndex > 0)\n            { // Fire multiple events with the same frame.\n                if (frames[frameIndex - 1] != frame) break;\n                frameIndex--;\n            }\n        }\n        var events = this.events;\n        for (; frameIndex < frameCount && time >= frames[frameIndex]; frameIndex++)\n            firedEvents.push(events[frameIndex]);\n    }\n};\nmodule.exports = spine.EventTimeline;\n\n","var spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.FfdTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = [];\n    this.frames.length = frameCount;\n    this.frameVertices = [];\n    this.frameVertices.length = frameCount;\n};\nspine.FfdTimeline.prototype = {\n    slotIndex: 0,\n    attachment: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length;\n    },\n    setFrame: function (frameIndex, time, vertices)\n    {\n        this.frames[frameIndex] = time;\n        this.frameVertices[frameIndex] = vertices;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var slot = skeleton.slots[this.slotIndex];\n        var slotAttachment = slot.attachment;\n        if (slotAttachment && (!slotAttachment.applyFFD || !slotAttachment.applyFFD(this.attachment))) return;\n\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var frameVertices = this.frameVertices;\n        var vertexCount = frameVertices[0].length;\n\n        var vertices = slot.attachmentVertices;\n        if (vertices.length != vertexCount) {\n            vertices = slot.attachmentVertices = [];\n            for (var k = 0; k < vertexCount; k++) vertices.push(0);\n            // Don't mix from uninitialized slot vertices.\n            alpha = 1;\n        }\n\n        if (time >= frames[frames.length - 1])\n        { // Time is after last frame.\n            var lastVertices = frameVertices[frames.length - 1];\n            if (alpha < 1)\n            {\n                for (var i = 0; i < vertexCount; i++)\n                    vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\n            } else {\n                for (var i = 0; i < vertexCount; i++)\n                    vertices[i] = lastVertices[i];\n            }\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frameIndex = spine.Animation.binarySearch1(frames, time);\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 1] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex - 1, percent < 0 ? 0 : (percent > 1 ? 1 : percent));\n\n        var prevVertices = frameVertices[frameIndex - 1];\n        var nextVertices = frameVertices[frameIndex];\n\n        if (alpha < 1)\n        {\n            for (var i = 0; i < vertexCount; i++)\n            {\n                var prev = prevVertices[i];\n                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\n            }\n        } else {\n            for (var i = 0; i < vertexCount; i++)\n            {\n                var prev = prevVertices[i];\n                vertices[i] = prev + (nextVertices[i] - prev) * percent;\n            }\n        }\n    }\n};\nmodule.exports = spine.FfdTimeline;\n\n","var spine = require('../SpineUtil');\nspine.IkConstraint = function (data, skeleton)\n{\n    this.data = data;\n    this.mix = data.mix;\n    this.bendDirection = data.bendDirection;\n\n    this.bones = [];\n    for (var i = 0, n = data.bones.length; i < n; i++)\n        this.bones.push(skeleton.findBone(data.bones[i].name));\n    this.target = skeleton.findBone(data.target.name);\n};\nspine.IkConstraint.prototype = {\n    update: function() {\n        this.apply();\n    },\n    apply: function ()\n    {\n        var target = this.target;\n        var bones = this.bones;\n        switch (bones.length)\n        {\n        case 1:\n            spine.IkConstraint.apply1(bones[0], target.worldX, target.worldY, this.mix);\n            break;\n        case 2:\n            spine.IkConstraint.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.mix);\n            break;\n        }\n    }\n};\n/** Adjusts the bone rotation so the tip is as close to the target position as possible. The target is specified in the world\n * coordinate system. */\nspine.IkConstraint.apply1 = function (bone, targetX, targetY, alpha)\n{\n    var parentRotation = bone.parent ? bone.parent.getWorldRotationX(): 0;\n    var rotation = bone.rotation;\n    var rotationIK = Math.atan2(targetY - bone.worldY, targetX - bone.worldX) * spine.radDeg - parentRotation;\n    if ((bone.worldSignX != bone.worldSignY) != (bone.skeleton.flipX != (bone.skeleton.flipY != spine.Bone.yDown))) rotationIK = 360 - rotationIK;\n    if (rotationIK > 180)\n        rotationIK -= 360;\n    else if (rotationIK < -180) rotationIK += 360;\n    bone.rotationIK = rotation + (rotationIK - rotation) * alpha;\n    bone.updateWorldTransform();\n};\n/** Adjusts the parent and child bone rotations so the tip of the child is as close to the target position as possible. The\n * target is specified in the world coordinate system.\n * @param child Any descendant bone of the parent. */\nspine.IkConstraint.apply2 = function (parent, child, targetX, targetY, bendDir, alpha)\n{\n    if (alpha == 0) return;\n    var px = parent.x, py = parent.y, psx = parent.scaleX, psy = parent.scaleY, csx = child.scaleX, cy = child.y;\n    var offset1, offset2, sign2;\n    if (psx < 0) {\n        psx = -psx;\n        offset1 = 180;\n        sign2 = -1;\n    } else {\n        offset1 = 0;\n        sign2 = 1;\n    }\n    if (psy < 0) {\n        psy = -psy;\n        sign2 = -sign2;\n    }\n    if (csx < 0) {\n        csx = -csx;\n        offset2 = 180;\n    } else\n        offset2 = 0;\n    var pp = parent.parent;\n    var ppm = pp.matrix;\n    var tx, ty, dx, dy;\n    if (pp == null) {\n        tx = targetX - px;\n        ty = targetY - py;\n        dx = child.worldX - px;\n        dy = child.worldY - py;\n    } else {\n        var a = ppm.a, b = ppm.c, c = ppm.b, d = ppm.d, invDet = 1 / (a * d - b * c);\n        var wx = ppm.tx, wy = ppm.ty, x = targetX - wx, y = targetY - wy;\n        tx = (x * d - y * b) * invDet - px;\n        ty = (y * a - x * c) * invDet - py;\n        x = child.worldX - wx;\n        y = child.worldY - wy;\n        dx = (x * d - y * b) * invDet - px;\n        dy = (y * a - x * c) * invDet - py;\n    }\n    var l1 = Math.sqrt(dx * dx + dy * dy), l2 = child.data.length * csx, a1, a2;\n    outer:\n        if (Math.abs(psx - psy) <= 0.0001) {\n            l2 *= psx;\n            var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n            if (cos < -1)\n                cos = -1;\n            else if (cos > 1) cos = 1;\n            a2 = Math.acos(cos) * bendDir;\n            var a = l1 + l2 * cos, o = l2 * Math.sin(a2);\n            a1 = Math.atan2(ty * a - tx * o, tx * a + ty * o);\n        } else {\n            cy = 0;\n            var a = psx * l2, b = psy * l2, ta = Math.atan2(ty, tx);\n            var aa = a * a, bb = b * b, ll = l1 * l1, dd = tx * tx + ty * ty;\n            var c0 = bb * ll + aa * dd - aa * bb, c1 = -2 * bb * l1, c2 = bb - aa;\n            var d = c1 * c1 - 4 * c2 * c0;\n            if (d >= 0) {\n                var q = Math.sqrt(d);\n                if (c1 < 0) q = -q;\n                q = -(c1 + q) / 2;\n                var r0 = q / c2, r1 = c0 / q;\n                var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n                if (r * r <= dd) {\n                    var y = Math.sqrt(dd - r * r) * bendDir;\n                    a1 = ta - Math.atan2(y, r);\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\n                    break outer;\n                }\n            }\n            var minAngle = 0, minDist = Infinity, minX = 0, minY = 0;\n            var maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;\n            var x = l1 + a, dist = x * x;\n            if (dist > maxDist) {\n                maxAngle = 0;\n                maxDist = dist;\n                maxX = x;\n            }\n            x = l1 - a;\n            dist = x * x;\n            if (dist < minDist) {\n                minAngle = Math.PI;\n                minDist = dist;\n                minX = x;\n            }\n            var angle = Math.acos(-a * l1 / (aa - bb));\n            x = a * Math.cos(angle) + l1;\n            var y = b * Math.sin(angle);\n            dist = x * x + y * y;\n            if (dist < minDist) {\n                minAngle = angle;\n                minDist = dist;\n                minX = x;\n                minY = y;\n            }\n            if (dist > maxDist) {\n                maxAngle = angle;\n                maxDist = dist;\n                maxX = x;\n                maxY = y;\n            }\n            if (dd <= (minDist + maxDist) / 2) {\n                a1 = ta - Math.atan2(minY * bendDir, minX);\n                a2 = minAngle * bendDir;\n            } else {\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                a2 = maxAngle * bendDir;\n            }\n        }\n    var offset = Math.atan2(cy, child.x) * sign2;\n    a1 = (a1 - offset) * spine.radDeg + offset1;\n    a2 = (a2 + offset) * spine.radDeg * sign2 + offset2;\n    if (a1 > 180)\n        a1 -= 360;\n    else if (a1 < -180) a1 += 360;\n    if (a2 > 180)\n        a2 -= 360;\n    else if (a2 < -180) a2 += 360;\n    var rotation = parent.rotation;\n    parent.rotationIK = rotation + (a1 - rotation) * alpha;\n    parent.updateWorldTransform();\n    rotation = child.rotation;\n    child.rotationIK = rotation + (a2 - rotation) * alpha;\n    child.updateWorldTransform();\n};\nmodule.exports = spine.IkConstraint;\n\n","var spine = require('../SpineUtil') || {};\nspine.IkConstraintData = function (name)\n{\n    this.name = name;\n    this.bones = [];\n};\nspine.IkConstraintData.prototype = {\n    target: null,\n    bendDirection: 1,\n    mix: 1\n};\nmodule.exports = spine.IkConstraintData;\n\n","var spine = require('../SpineUtil') || {};\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.IkConstraintTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, mix, bendDirection, ...\n    this.frames.length = frameCount * 3;\n};\nspine.IkConstraintTimeline.prototype = {\n    ikConstraintIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length / 3;\n    },\n    setFrame: function (frameIndex, time, mix, bendDirection)\n    {\n        frameIndex *= 3;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = mix;\n        this.frames[frameIndex + 2] = bendDirection;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var ikConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\n\n        if (time >= frames[frames.length - 3])\n        { // Time is after last frame.\n            ikConstraint.mix += (frames[frames.length - 2] - ikConstraint.mix) * alpha;\n            ikConstraint.bendDirection = frames[frames.length - 1];\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\n        var prevFrameMix = frames[frameIndex + -2/*PREV_FRAME_MIX*/];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\n\n        var mix = prevFrameMix + (frames[frameIndex + 1/*FRAME_MIX*/] - prevFrameMix) * percent;\n        ikConstraint.mix += (mix - ikConstraint.mix) * alpha;\n        ikConstraint.bendDirection = frames[frameIndex + -1/*PREV_FRAME_BEND_DIRECTION*/];\n    }\n};\nmodule.exports = spine.IkConstraintTimeline;\n\n","var spine = require('../SpineUtil') || {};\nspine.AttachmentType = require('./AttachmentType');\nspine.MeshAttachment = function (name)\n{\n    this.name = name;\n};\nspine.MeshAttachment.prototype = {\n    type: spine.AttachmentType.mesh,\n    parentMesh: null,\n    inheritFFD: false,\n    vertices: null,\n    uvs: null,\n    regionUVs: null,\n    triangles: null,\n    hullLength: 0,\n    r: 1, g: 1, b: 1, a: 1,\n    path: null,\n    rendererObject: null,\n    edges: null,\n    width: 0, height: 0,\n    updateUVs: function ()\n    {\n        var n = this.regionUVs.length;\n        if (!this.uvs || this.uvs.length != n)\n        {\n            this.uvs = new spine.Float32Array(n);\n        }\n        var region = this.rendererObject;\n        if (!region) return;\n        var texture = region.texture;\n        var r = texture._uvs;\n        var w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\n        var x = region.offsetX, y = region.pixiOffsetY;\n        for (var i = 0; i < n; i += 2)\n        {\n            var u = this.regionUVs[i], v = this.regionUVs[i+1];\n            u = (u * w2 - x) / w1;\n            v = (v * h2 - y) / h1;\n            this.uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1-v) + (r.x3 * (1 - u) + r.x2 * u) * v;\n            this.uvs[i+1] = (r.y0 * (1 - u) + r.y1 * u) * (1-v) + (r.y3 * (1 - u) + r.y2 * u) * v;\n        }\n    },\n    computeWorldVertices: function (x, y, slot, worldVertices)\n    {\n        var bone = slot.bone;\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\n        var vertices = this.vertices;\n        var verticesCount = vertices.length;\n        if (slot.attachmentVertices.length == verticesCount) vertices = slot.attachmentVertices;\n        for (var i = 0; i < verticesCount; i += 2)\n        {\n            var vx = vertices[i];\n            var vy = vertices[i + 1];\n            worldVertices[i] = vx * m00 + vy * m01 + x;\n            worldVertices[i + 1] = vx * m10 + vy * m11 + y;\n        }\n    },\n    applyFFD: function(sourceAttachment) {\n        return this === sourceAttachment || (this.inheritFFD && parentMesh === sourceAttachment);\n    },\n    setParentMesh: function(parentMesh) {\n        this.parentMesh = parentMesh;\n        if (parentMesh != null) {\n            this.vertices = parentMesh.vertices;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n        }\n    }\n};\nmodule.exports = spine.MeshAttachment;\n\n","var spine = require('../SpineUtil');\nspine.AttachmentType = require('./AttachmentType');\nspine.RegionAttachment = function (name)\n{\n    this.name = name;\n    this.offset = [];\n    this.offset.length = 8;\n    this.uvs = [];\n    this.uvs.length = 8;\n};\nspine.RegionAttachment.prototype = {\n    type: spine.AttachmentType.region,\n    x: 0, y: 0,\n    rotation: 0,\n    scaleX: 1, scaleY: 1,\n    width: 0, height: 0,\n    r: 1, g: 1, b: 1, a: 1,\n    path: null,\n    rendererObject: null,\n    regionOffsetX: 0, regionOffsetY: 0,\n    regionWidth: 0, regionHeight: 0,\n    regionOriginalWidth: 0, regionOriginalHeight: 0,\n    setUVs: function (u, v, u2, v2, rotate)\n    {\n        var uvs = this.uvs;\n        if (rotate)\n        {\n            uvs[2/*X2*/] = u;\n            uvs[3/*Y2*/] = v2;\n            uvs[4/*X3*/] = u;\n            uvs[5/*Y3*/] = v;\n            uvs[6/*X4*/] = u2;\n            uvs[7/*Y4*/] = v;\n            uvs[0/*X1*/] = u2;\n            uvs[1/*Y1*/] = v2;\n        } else {\n            uvs[0/*X1*/] = u;\n            uvs[1/*Y1*/] = v2;\n            uvs[2/*X2*/] = u;\n            uvs[3/*Y2*/] = v;\n            uvs[4/*X3*/] = u2;\n            uvs[5/*Y3*/] = v;\n            uvs[6/*X4*/] = u2;\n            uvs[7/*Y4*/] = v2;\n        }\n    },\n    updateOffset: function ()\n    {\n        var regionScaleX = this.width / this.regionOriginalWidth * this.scaleX;\n        var regionScaleY = this.height / this.regionOriginalHeight * this.scaleY;\n        var localX = -this.width / 2 * this.scaleX + this.regionOffsetX * regionScaleX;\n        var localY = -this.height / 2 * this.scaleY + this.regionOffsetY * regionScaleY;\n        var localX2 = localX + this.regionWidth * regionScaleX;\n        var localY2 = localY + this.regionHeight * regionScaleY;\n        var radians = this.rotation * spine.degRad;\n        var cos = Math.cos(radians);\n        var sin = Math.sin(radians);\n        var localXCos = localX * cos + this.x;\n        var localXSin = localX * sin;\n        var localYCos = localY * cos + this.y;\n        var localYSin = localY * sin;\n        var localX2Cos = localX2 * cos + this.x;\n        var localX2Sin = localX2 * sin;\n        var localY2Cos = localY2 * cos + this.y;\n        var localY2Sin = localY2 * sin;\n        var offset = this.offset;\n        offset[0/*X1*/] = localXCos - localYSin;\n        offset[1/*Y1*/] = localYCos + localXSin;\n        offset[2/*X2*/] = localXCos - localY2Sin;\n        offset[3/*Y2*/] = localY2Cos + localXSin;\n        offset[4/*X3*/] = localX2Cos - localY2Sin;\n        offset[5/*Y3*/] = localY2Cos + localX2Sin;\n        offset[6/*X4*/] = localX2Cos - localYSin;\n        offset[7/*Y4*/] = localYCos + localX2Sin;\n    },\n    computeVertices: function (x, y, bone, vertices)\n    {\n        x += bone.worldX;\n        y += bone.worldY;\n        var m00 = bone.matrix.a, m01 = bone.matrix.c, m10 = bone.matrix.b, m11 = bone.matrix.d;\n        var offset = this.offset;\n        vertices[0/*X1*/] = offset[0/*X1*/] * m00 + offset[1/*Y1*/] * m01 + x;\n        vertices[1/*Y1*/] = offset[0/*X1*/] * m10 + offset[1/*Y1*/] * m11 + y;\n        vertices[2/*X2*/] = offset[2/*X2*/] * m00 + offset[3/*Y2*/] * m01 + x;\n        vertices[3/*Y2*/] = offset[2/*X2*/] * m10 + offset[3/*Y2*/] * m11 + y;\n        vertices[4/*X3*/] = offset[4/*X3*/] * m00 + offset[5/*X3*/] * m01 + x;\n        vertices[5/*X3*/] = offset[4/*X3*/] * m10 + offset[5/*X3*/] * m11 + y;\n        vertices[6/*X4*/] = offset[6/*X4*/] * m00 + offset[7/*Y4*/] * m01 + x;\n        vertices[7/*Y4*/] = offset[6/*X4*/] * m10 + offset[7/*Y4*/] * m11 + y;\n    }\n};\nmodule.exports = spine.RegionAttachment;\n\n","var spine = require('../SpineUtil') || {};\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.RotateTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, angle, ...\n    this.frames.length = frameCount * 2;\n};\nspine.RotateTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length / 2;\n    },\n    setFrame: function (frameIndex, time, angle)\n    {\n        frameIndex *= 2;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = angle;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - 2])\n        { // Time is after last frame.\n            var amount = bone.data.rotation + frames[frames.length - 1] - bone.rotation;\n            while (amount > 180)\n                amount -= 360;\n            while (amount < -180)\n                amount += 360;\n            bone.rotation += amount * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frameIndex = spine.Animation.binarySearch(frames, time, 2);\n        var prevFrameValue = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex - 2/*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 2 - 1, percent);\n\n        var amount = frames[frameIndex + 1/*FRAME_VALUE*/] - prevFrameValue;\n        while (amount > 180)\n            amount -= 360;\n        while (amount < -180)\n            amount += 360;\n        amount = bone.data.rotation + (prevFrameValue + amount * percent) - bone.rotation;\n        while (amount > 180)\n            amount -= 360;\n        while (amount < -180)\n            amount += 360;\n        bone.rotation += amount * alpha;\n    }\n};\nmodule.exports = spine.RotateTimeline;\n\n","var spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.ScaleTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, x, y, ...\n    this.frames.length = frameCount * 3;\n};\nspine.ScaleTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length / 3;\n    },\n    setFrame: function (frameIndex, time, x, y)\n    {\n        frameIndex *= 3;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = x;\n        this.frames[frameIndex + 2] = y;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - 3])\n        { // Time is after last frame.\n            bone.scaleX += (bone.data.scaleX * frames[frames.length - 2] - bone.scaleX) * alpha;\n            bone.scaleY += (bone.data.scaleY * frames[frames.length - 1] - bone.scaleY) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\n        var prevFrameX = frames[frameIndex - 2];\n        var prevFrameY = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\n\n        bone.scaleX += (bone.data.scaleX * (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.scaleX) * alpha;\n        bone.scaleY += (bone.data.scaleY * (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.scaleY) * alpha;\n    }\n};\nmodule.exports = spine.ScaleTimeline;\n\n","var spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.ShearTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, x, y, ...\n    this.frames.length = frameCount * 3;\n};\nspine.ShearTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length / 3;\n    },\n    setFrame: function (frameIndex, time, x, y)\n    {\n        frameIndex *= 3;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = x;\n        this.frames[frameIndex + 2] = y;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - 3])\n        { // Time is after last frame.\n            bone.shearX += (bone.data.shearX * frames[frames.length - 2] - bone.shearX) * alpha;\n            bone.shearY += (bone.data.shearY * frames[frames.length - 1] - bone.shearY) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\n        var prevFrameX = frames[frameIndex - 2];\n        var prevFrameY = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\n\n        bone.shearX += (bone.data.shearX + (prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent) - bone.shearX) * alpha;\n        bone.shearY += (bone.data.shearY + (prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent) - bone.shearY) * alpha;\n    }\n};\nmodule.exports = spine.ShearTimeline;\n\n","var spine = require('../SpineUtil');\nspine.Bone = require('./Bone');\nspine.Slot = require('./Slot');\nspine.IkConstraint = require('./IkConstraint');\nspine.Skeleton = function (skeletonData)\n{\n    this.data = skeletonData;\n\n    this.bones = [];\n    for (var i = 0, n = skeletonData.bones.length; i < n; i++)\n    {\n        var boneData = skeletonData.bones[i];\n        var parent = !boneData.parent ? null : this.bones[skeletonData.bones.indexOf(boneData.parent)];\n        this.bones.push(new spine.Bone(boneData, this, parent));\n    }\n\n    this.slots = [];\n    this.drawOrder = [];\n    for (var i = 0, n = skeletonData.slots.length; i < n; i++)\n    {\n        var slotData = skeletonData.slots[i];\n        var bone = this.bones[skeletonData.bones.indexOf(slotData.boneData)];\n        var slot = new spine.Slot(slotData, bone);\n        this.slots.push(slot);\n        this.drawOrder.push(i);\n    }\n\n    this.ikConstraints = [];\n    for (var i = 0, n = skeletonData.ikConstraints.length; i < n; i++)\n        this.ikConstraints.push(new spine.IkConstraint(skeletonData.ikConstraints[i], this));\n\n    this.transformConstraints = [];\n    for (var i = 0, n = skeletonData.transformConstraints.length; i < n; i++)\n        this.transformConstraints.push(new spine.TransformConstraint(skeletonData.transformConstraints[i], this));\n\n    this.boneCache = [];\n    this.updateCache();\n};\nspine.Skeleton.prototype = {\n    x: 0, y: 0,\n    skin: null,\n    r: 1, g: 1, b: 1, a: 1,\n    time: 0,\n    flipX: false, flipY: false,\n    /** Caches information about bones and IK constraints. Must be called if bones or IK constraints are added or removed. */\n    updateCache: function ()\n    {\n        var ikConstraints = this.ikConstraints;\n        var ikConstraintsCount = ikConstraints.length;\n        var transformConstraints = this.transformConstraints;\n        var transformConstraintsCount = transformConstraints.length;\n\n        var boneCache = this.boneCache;\n        boneCache.length = 0;\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var bone = bones[i];\n            boneCache.push(bone);\n            for (var j=0; j < transformConstraintsCount; j++) {\n                if (transformConstraints[j].bone == bone) {\n                    boneCache.push(transformConstraints[j]);\n                }\n            }\n            for (var j=0; j < ikConstraintsCount; j++) {\n                if (ikConstraints[j].bones[ikConstraints[j].bones.length-1] == bone) {\n                    boneCache.push(ikConstraints[j]);\n                    break;\n                }\n            }\n        }\n    },\n    /** Updates the world transform for each bone. */\n    updateWorldTransform: function ()\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var bone = bones[i];\n            bone.rotationIK = bone.rotation;\n        }\n        var boneCache = this.boneCache;\n        for (var i = 0, n = boneCache.length; i < n; i++) {\n            boneCache[i].update();\n        }\n    },\n    /** Sets the bones and slots to their setup pose values. */\n    setToSetupPose: function ()\n    {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    },\n    setBonesToSetupPose: function ()\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            bones[i].setToSetupPose();\n\n        var ikConstraints = this.ikConstraints;\n        for (var i = 0, n = ikConstraints.length; i < n; i++)\n        {\n            var ikConstraint = ikConstraints[i];\n            ikConstraint.bendDirection = ikConstraint.data.bendDirection;\n            ikConstraint.mix = ikConstraint.data.mix;\n        }\n\n        var transformConstraints = this.transformConstraints;\n        for (var i = 0, n = transformConstraints.length; i < n; i++)\n        {\n            var constraint = transformConstraints[i];\n            var data = constraint.data;\n            constraint.rotateMix = data.rotateMix;\n            constraint.translateMix = data.translateMix;\n            constraint.scaleMix = data.scaleMix;\n            constraint.shearMix = data.shearMix;\n        }\n    },\n    setSlotsToSetupPose: function ()\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            slots[i].setToSetupPose(i);\n        }\n\n        this.resetDrawOrder();\n    },\n    /** @return May return null. */\n    getRootBone: function ()\n    {\n        return this.bones.length ? this.bones[0] : null;\n    },\n    /** @return May be null. */\n    findBone: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return bones[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].data.name == boneName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSlot: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return slots[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].data.name == slotName) return i;\n        return -1;\n    },\n    setSkinByName: function (skinName)\n    {\n        var skin = this.data.findSkin(skinName);\n        if (!skin) throw \"Skin not found: \" + skinName;\n        this.setSkin(skin);\n    },\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#getDefaultSkin() default skin}.\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was\n     * no old skin, each slot's setup mode attachment is attached from the new skin.\n     * @param newSkin May be null. */\n    setSkin: function (newSkin)\n    {\n        if (newSkin)\n        {\n            if (this.skin)\n                newSkin._attachAll(this, this.skin);\n            else\n            {\n                var slots = this.slots;\n                for (var i = 0, n = slots.length; i < n; i++)\n                {\n                    var slot = slots[i];\n                    var name = slot.data.attachmentName;\n                    if (name)\n                    {\n                        var attachment = newSkin.getAttachment(i, name);\n                        if (attachment) slot.setAttachment(attachment);\n                    }\n                }\n            }\n        }\n        this.skin = newSkin;\n    },\n    /** @return May be null. */\n    getAttachmentBySlotName: function (slotName, attachmentName)\n    {\n        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(slotName), attachmentName);\n    },\n    /** @return May be null. */\n    getAttachmentBySlotIndex: function (slotIndex, attachmentName)\n    {\n        if (this.skin)\n        {\n            var attachment = this.skin.getAttachment(slotIndex, attachmentName);\n            if (attachment) return attachment;\n        }\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n        return null;\n    },\n    /** @param attachmentName May be null. */\n    setAttachment: function (slotName, attachmentName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            var slot = slots[i];\n            if (slot.data.name == slotName)\n            {\n                var attachment = null;\n                if (attachmentName)\n                {\n                    attachment = this.getAttachmentBySlotIndex(i, attachmentName);\n                    if (!attachment) throw \"Attachment not found: \" + attachmentName + \", for slot: \" + slotName;\n                }\n                slot.setAttachment(attachment);\n                return;\n            }\n        }\n        throw \"Slot not found: \" + slotName;\n    },\n    /** @return May be null. */\n    findIkConstraint: function (constraintName)\n    {\n        var constraints = this.ikConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].data.name == constraintName) return constraints[i];\n        return null;\n    },\n    findTransformConstraint: function (constraintName)\n    {\n        var constraints = this.transformConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].data.name == constraintName) return constraints[i];\n        return null;\n    },\n    update: function (delta)\n    {\n        this.time += delta;\n    },\n    resetDrawOrder: function () {\n        for (var i = 0, n = this.drawOrder.length; i < n; i++)\n        {\n            this.drawOrder[i] = i;\n        }\n    }\n};\nmodule.exports = spine.Skeleton;\n\n","var spine = require('../SpineRuntime') || {};\nspine.AttachmentType = require('./AttachmentType');\nspine.SkeletonBounds = function ()\n{\n    this.polygonPool = [];\n    this.polygons = [];\n    this.boundingBoxes = [];\n};\nspine.SkeletonBounds.prototype = {\n    minX: 0, minY: 0, maxX: 0, maxY: 0,\n    update: function (skeleton, updateAabb)\n    {\n        var slots = skeleton.slots;\n        var slotCount = slots.length;\n        var x = skeleton.x, y = skeleton.y;\n        var boundingBoxes = this.boundingBoxes;\n        var polygonPool = this.polygonPool;\n        var polygons = this.polygons;\n\n        boundingBoxes.length = 0;\n        for (var i = 0, n = polygons.length; i < n; i++)\n            polygonPool.push(polygons[i]);\n        polygons.length = 0;\n\n        for (var i = 0; i < slotCount; i++)\n        {\n            var slot = slots[i];\n            var boundingBox = slot.attachment;\n            if (boundingBox.type != spine.AttachmentType.boundingbox) continue;\n            boundingBoxes.push(boundingBox);\n\n            var poolCount = polygonPool.length, polygon;\n            if (poolCount > 0)\n            {\n                polygon = polygonPool[poolCount - 1];\n                polygonPool.splice(poolCount - 1, 1);\n            } else\n                polygon = [];\n            polygons.push(polygon);\n\n            polygon.length = boundingBox.vertices.length;\n            boundingBox.computeWorldVertices(x, y, slot.bone, polygon);\n        }\n\n        if (updateAabb) this.aabbCompute();\n    },\n    aabbCompute: function ()\n    {\n        var polygons = this.polygons;\n        var minX = Number.MAX_VALUE, minY = Number.MAX_VALUE, maxX = Number.MIN_VALUE, maxY = Number.MIN_VALUE;\n        for (var i = 0, n = polygons.length; i < n; i++)\n        {\n            var vertices = polygons[i];\n            for (var ii = 0, nn = vertices.length; ii < nn; ii += 2)\n            {\n                var x = vertices[ii];\n                var y = vertices[ii + 1];\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n                maxX = Math.max(maxX, x);\n                maxY = Math.max(maxY, y);\n            }\n        }\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    },\n    /** Returns true if the axis aligned bounding box contains the point. */\n    aabbContainsPoint: function (x, y)\n    {\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n    },\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\n    aabbIntersectsSegment: function (x1, y1, x2, y2)\n    {\n        var minX = this.minX, minY = this.minY, maxX = this.maxX, maxY = this.maxY;\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY))\n            return false;\n        var m = (y2 - y1) / (x2 - x1);\n        var y = m * (minX - x1) + y1;\n        if (y > minY && y < maxY) return true;\n        y = m * (maxX - x1) + y1;\n        if (y > minY && y < maxY) return true;\n        var x = (minY - y1) / m + x1;\n        if (x > minX && x < maxX) return true;\n        x = (maxY - y1) / m + x1;\n        if (x > minX && x < maxX) return true;\n        return false;\n    },\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\n    aabbIntersectsSkeleton: function (bounds)\n    {\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n    },\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\n    containsPoint: function (x, y)\n    {\n        var polygons = this.polygons;\n        for (var i = 0, n = polygons.length; i < n; i++)\n            if (this.polygonContainsPoint(polygons[i], x, y)) return this.boundingBoxes[i];\n        return null;\n    },\n    /** Returns the first bounding box attachment that contains the line segment, or null. When doing many checks, it is usually\n     * more efficient to only call this method if {@link #aabbIntersectsSegment(float, float, float, float)} returns true. */\n    intersectsSegment: function (x1, y1, x2, y2)\n    {\n        var polygons = this.polygons;\n        for (var i = 0, n = polygons.length; i < n; i++)\n            if (polygons[i].intersectsSegment(x1, y1, x2, y2)) return this.boundingBoxes[i];\n        return null;\n    },\n    /** Returns true if the polygon contains the point. */\n    polygonContainsPoint: function (polygon, x, y)\n    {\n        var nn = polygon.length;\n        var prevIndex = nn - 2;\n        var inside = false;\n        for (var ii = 0; ii < nn; ii += 2)\n        {\n            var vertexY = polygon[ii + 1];\n            var prevY = polygon[prevIndex + 1];\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y))\n            {\n                var vertexX = polygon[ii];\n                if (vertexX + (y - vertexY) / (prevY - vertexY) * (polygon[prevIndex] - vertexX) < x) inside = !inside;\n            }\n            prevIndex = ii;\n        }\n        return inside;\n    },\n    /** Returns true if the polygon contains the line segment. */\n    polygonIntersectsSegment: function (polygon, x1, y1, x2, y2)\n    {\n        var nn = polygon.length;\n        var width12 = x1 - x2, height12 = y1 - y2;\n        var det1 = x1 * y2 - y1 * x2;\n        var x3 = polygon[nn - 2], y3 = polygon[nn - 1];\n        for (var ii = 0; ii < nn; ii += 2)\n        {\n            var x4 = polygon[ii], y4 = polygon[ii + 1];\n            var det2 = x3 * y4 - y3 * x4;\n            var width34 = x3 - x4, height34 = y3 - y4;\n            var det3 = width12 * height34 - height12 * width34;\n            var x = (det1 * width34 - width12 * det2) / det3;\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1)))\n            {\n                var y = (det1 * height34 - height12 * det2) / det3;\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\n            }\n            x3 = x4;\n            y3 = y4;\n        }\n        return false;\n    },\n    getPolygon: function (attachment)\n    {\n        var index = this.boundingBoxes.indexOf(attachment);\n        return index == -1 ? null : this.polygons[index];\n    },\n    getWidth: function ()\n    {\n        return this.maxX - this.minX;\n    },\n    getHeight: function ()\n    {\n        return this.maxY - this.minY;\n    }\n};\nmodule.exports = spine.SkeletonBounds;\n\n","var spine = require('../SpineUtil');\nspine.SkeletonData = function ()\n{\n    this.bones = [];\n    this.slots = [];\n    this.skins = [];\n    this.events = [];\n    this.animations = [];\n    this.ikConstraints = [];\n    this.transformConstraints = [];\n};\nspine.SkeletonData.prototype = {\n    name: null,\n    defaultSkin: null,\n    width: 0, height: 0,\n    version: null, hash: null,\n    /** @return May be null. */\n    findBone: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return bones[i];\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findBoneIndex: function (boneName)\n    {\n        var bones = this.bones;\n        for (var i = 0, n = bones.length; i < n; i++)\n            if (bones[i].name == boneName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSlot: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            if (slots[i].name == slotName) return this.slots[i];\n        }\n        return null;\n    },\n    /** @return -1 if the bone was not found. */\n    findSlotIndex: function (slotName)\n    {\n        var slots = this.slots;\n        for (var i = 0, n = slots.length; i < n; i++)\n            if (slots[i].name == slotName) return i;\n        return -1;\n    },\n    /** @return May be null. */\n    findSkin: function (skinName)\n    {\n        var skins = this.skins;\n        for (var i = 0, n = skins.length; i < n; i++)\n            if (skins[i].name == skinName) return skins[i];\n        return null;\n    },\n    /** @return May be null. */\n    findEvent: function (eventName)\n    {\n        var events = this.events;\n        for (var i = 0, n = events.length; i < n; i++)\n            if (events[i].name == eventName) return events[i];\n        return null;\n    },\n    /** @return May be null. */\n    findAnimation: function (animationName)\n    {\n        var animations = this.animations;\n        for (var i = 0, n = animations.length; i < n; i++)\n            if (animations[i].name == animationName) return animations[i];\n        return null;\n    },\n    /** @return May be null. */\n    findIkConstraint: function (constraintName)\n    {\n        var constraints = this.ikConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].name == constraintName) return constraints[i];\n        return null;\n    },\n    /** @return May be null. */\n    findTransformConstraint: function (constraintName)\n    {\n        var constraints = this.transformConstraints;\n        for (var i = 0, n = constraints.length; i < n; i++)\n            if (constraints[i].name == constraintName) return constraints[i];\n        return null;\n    },\n};\nmodule.exports = spine.SkeletonData;\n\n","var spine = require('../SpineUtil');\nspine.SkeletonData = require('./SkeletonData');\nspine.BoneData = require('./BoneData');\nspine.IkConstraintData = require('./IkConstraintData');\nspine.TransformConstraintData = require('./TransformConstraintData');\nspine.SlotData = require('./SlotData');\nspine.Skin = require('./Skin');\nspine.EventData = require('./EventData');\nspine.AttachmentType = require('./AttachmentType');\nspine.ColorTimeline = require('./ColorTimeline');\nspine.AttachmentTimeline = require('./AttachmentTimeline');\nspine.RotateTimeline = require('./RotateTimeline');\nspine.ScaleTimeline = require('./ScaleTimeline');\nspine.TranslateTimeline = require('./TranslateTimeline');\nspine.ShearTimeline = require('./ShearTimeline');\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\nspine.TransformConstraintTimeline = require('./TransformConstraintTimeline');\nspine.FfdTimeline = require('./FfdTimeline');\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\nspine.EventTimeline = require('./EventTimeline');\nspine.Event = require('./Event');\nspine.Animation = require('./Animation');\n\nfunction LinkedMesh(mesh, skin, slotIndex, parent) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n}\n\nspine.SkeletonJsonParser = function (attachmentLoader)\n{\n    if (attachmentLoader.pages) {\n        //its an atlas, we have to wrap it\n        this.attachmentLoader = new spine.AtlasAttachmentLoader(attachmentLoader);\n    } else {\n        //got a loader, thats good\n        this.attachmentLoader = attachmentLoader;\n    }\n    if (!attachmentLoader.newRegionAttachment) {\n        console.warn(\"SkeletonJsonParser accepts AtlasAttachmentLoader or atlas as first parameter\");\n    }\n    this.linkedMeshes = [];\n};\nspine.SkeletonJsonParser.prototype = {\n    scale: 1,\n    readSkeletonData: function (root, name)\n    {\n        var skeletonData = new spine.SkeletonData();\n        skeletonData.name = name;\n\n        var scale = this.scale;\n        // Skeleton.\n        var skeletonMap = root[\"skeleton\"];\n        if (skeletonMap)\n        {\n            skeletonData.hash = skeletonMap[\"hash\"];\n            skeletonData.version = skeletonMap[\"spine\"];\n            skeletonData.width = skeletonMap[\"width\"] || 0;\n            skeletonData.height = skeletonMap[\"height\"] || 0;\n        }\n\n        // Bones.\n        var bones = root[\"bones\"];\n        for (var i = 0, n = bones.length; i < n; i++)\n        {\n            var boneMap = bones[i];\n            var parent = null;\n            if (boneMap[\"parent\"])\n            {\n                parent = skeletonData.findBone(boneMap[\"parent\"]);\n                if (!parent) throw \"Parent bone not found: \" + boneMap[\"parent\"];\n            }\n            var boneData = new spine.BoneData(boneMap[\"name\"], parent);\n            boneData.length = (boneMap[\"length\"] || 0) * this.scale;\n            boneData.x = (boneMap[\"x\"] || 0) * this.scale;\n            boneData.y = (boneMap[\"y\"] || 0) * this.scale;\n            boneData.rotation = (boneMap[\"rotation\"] || 0);\n            boneData.scaleX = boneMap.hasOwnProperty(\"scaleX\") ? boneMap[\"scaleX\"] : 1;\n            boneData.scaleY = boneMap.hasOwnProperty(\"scaleY\") ? boneMap[\"scaleY\"] : 1;\n            boneData.shearX = boneMap[\"shearX\"] || 0;\n            boneData.shearY = boneMap[\"shearY\"] || 0;\n            boneData.inheritScale = boneMap.hasOwnProperty(\"inheritScale\") ? boneMap[\"inheritScale\"] : true;\n            boneData.inheritRotation = boneMap.hasOwnProperty(\"inheritRotation\") ? boneMap[\"inheritRotation\"] : true;\n            skeletonData.bones.push(boneData);\n        }\n\n        // IK constraints.\n        var ik = root[\"ik\"];\n        if (ik)\n        {\n            for (var i = 0, n = ik.length; i < n; i++)\n            {\n                var ikMap = ik[i];\n                var ikConstraintData = new spine.IkConstraintData(ikMap[\"name\"]);\n\n                var bones = ikMap[\"bones\"];\n                for (var ii = 0, nn = bones.length; ii < nn; ii++)\n                {\n                    var bone = skeletonData.findBone(bones[ii]);\n                    if (!bone) throw new Error( \"IK bone not found: \" + bones[ii] );\n                    ikConstraintData.bones.push(bone);\n                }\n\n                ikConstraintData.target = skeletonData.findBone(ikMap[\"target\"]);\n                if (!ikConstraintData.target) throw new Error(\"Target bone not found: \" + ikMap[\"target\"]);\n\n                ikConstraintData.bendDirection = (!ikMap.hasOwnProperty(\"bendPositive\") || ikMap[\"bendPositive\"]) ? 1 : -1;\n                ikConstraintData.mix = ikMap.hasOwnProperty(\"mix\") ? ikMap[\"mix\"] : 1;\n\n                skeletonData.ikConstraints.push(ikConstraintData);\n            }\n        }\n\n        var transform = root[\"transform\"];\n        if (transform) {\n            for (var i = 0, n = transform.length; i<n; i++) {\n                var transformMap = transform[i];\n                var transformData = new spine.TransformConstraintData(transformMap[\"name\"]);\n                transformData.bone = skeletonData.findBone(transformMap[\"bone\"]);\n                if (!transformData.bone) throw new Error(\"Transform bone not found: \" + transformData[\"bone\"]);\n                transformData.target = skeletonData.findBone(transformMap[\"target\"]);\n                if (!transformData.target) throw new Error(\"Target bone not found: \" + transformData[\"target\"]);\n\n                transformData.offsetRotation = transformMap[\"rotation\"] || 0;\n                transformData.offsetX = (transformMap[\"offsetX\"] || 0) * scale;\n                transformData.offsetY = (transformMap[\"offsetY\"] || 0) * scale;\n                transformData.offsetScaleX = (transformMap[\"scaleX\"] || 0) * scale;\n                transformData.offsetScaleY = (transformMap[\"scaleY\"] || 0) * scale;\n                transformData.offsetShearY = (transformMap[\"offsetShearY\"] || 0) * scale;\n\n                transformData.rotateMix = transformMap.hasOwnProperty(\"rotateMix\") ? transformMap[\"rotateMix\"] : 1;\n                transformData.translateMix = transformMap.hasOwnProperty(\"translateMix\") ? transformMap[\"translateMix\"] : 1;\n                transformData.scaleMix = transformMap.hasOwnProperty(\"scaleMix\") ? transformMap[\"scaleMix\"] : 1;\n                transformData.shearMix = transformMap.hasOwnProperty(\"shearMix\") ? transformMap[\"shearMix\"] : 1;\n\n                skeletonData.transformConstraints.push(transformData);\n            }\n        }\n\n        // Slots.\n        var slots = root[\"slots\"];\n        for (var i = 0, n = slots.length; i < n; i++)\n        {\n            var slotMap = slots[i];\n            var boneData = skeletonData.findBone(slotMap[\"bone\"]);\n            if (!boneData) throw \"Slot bone not found: \" + slotMap[\"bone\"];\n            var slotData = new spine.SlotData(slotMap[\"name\"], boneData);\n\n            var color = slotMap[\"color\"];\n            if (color)\n            {\n                slotData.r = this.toColor(color, 0);\n                slotData.g = this.toColor(color, 1);\n                slotData.b = this.toColor(color, 2);\n                slotData.a = this.toColor(color, 3);\n            }\n\n            slotData.attachmentName = slotMap[\"attachment\"];\n\n\n            slotData.blendMode = slotMap[\"blend\"] && spine.SlotData.PIXI_BLEND_MODE_MAP[slotMap[\"blend\"]] || spine.SlotData.PIXI_BLEND_MODE_MAP['normal'];\n\n            skeletonData.slots.push(slotData);\n        }\n\n        // Skins.\n        var skins = root[\"skins\"];\n        for (var skinName in skins)\n        {\n            if (!skins.hasOwnProperty(skinName)) continue;\n            var skinMap = skins[skinName];\n            var skin = new spine.Skin(skinName);\n            for (var slotName in skinMap)\n            {\n                if (!skinMap.hasOwnProperty(slotName)) continue;\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var slotEntry = skinMap[slotName];\n                for (var attachmentName in slotEntry)\n                {\n                    if (!slotEntry.hasOwnProperty(attachmentName)) continue;\n                    var attachment = this.readAttachment(skin, slotIndex, attachmentName, slotEntry[attachmentName]);\n                    if (attachment) skin.addAttachment(slotIndex, attachmentName, attachment);\n                }\n            }\n            skeletonData.skins.push(skin);\n            if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n        }\n\n        var linkedMeshes = this.linkedMeshes;\n        // Linked meshes.\n        for (var i = 0, n = linkedMeshes.size; i < n; i++) {\n            var linkedMesh = linkedMeshes[i];\n            var skin = linkedMesh.skin ? skeletonData.findSkin(linkedMesh.skin): skeletonData.defaultSkin;\n            var parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n            linkedMesh.mesh.setParentMesh(parent);\n            linkedMesh.mesh.updateUVs();\n        }\n        linkedMeshes.length = 0;\n\n        // Events.\n        var events = root[\"events\"];\n        for (var eventName in events)\n        {\n            if (!events.hasOwnProperty(eventName)) continue;\n            var eventMap = events[eventName];\n            var eventData = new spine.EventData(eventName);\n            eventData.intValue = eventMap[\"int\"] || 0;\n            eventData.floatValue = eventMap[\"float\"] || 0;\n            eventData.stringValue = eventMap[\"string\"] || null;\n            skeletonData.events.push(eventData);\n        }\n\n        // Animations.\n        var animations = root[\"animations\"];\n        for (var animationName in animations)\n        {\n            if (!animations.hasOwnProperty(animationName)) continue;\n            this.readAnimation(animationName, animations[animationName], skeletonData);\n        }\n\n        return skeletonData;\n    },\n    readAttachment: function (skin, slotIndex, name, map)\n    {\n        name = map[\"name\"] || name;\n\n        var type = spine.AttachmentType[map[\"type\"] || \"region\"];\n        var path = map[\"path\"] || name;\n\n        var scale = this.scale;\n        if (type == spine.AttachmentType.region)\n        {\n            var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n            if (!region) return null;\n            region.path = path;\n            region.x = (map[\"x\"] || 0) * scale;\n            region.y = (map[\"y\"] || 0) * scale;\n            region.scaleX = map.hasOwnProperty(\"scaleX\") ? map[\"scaleX\"] : 1;\n            region.scaleY = map.hasOwnProperty(\"scaleY\") ? map[\"scaleY\"] : 1;\n            region.rotation = map[\"rotation\"] || 0;\n            region.width = (map[\"width\"] || 0) * scale;\n            region.height = (map[\"height\"] || 0) * scale;\n\n            var color = map[\"color\"];\n            if (color)\n            {\n                region.r = this.toColor(color, 0);\n                region.g = this.toColor(color, 1);\n                region.b = this.toColor(color, 2);\n                region.a = this.toColor(color, 3);\n            }\n\n            region.updateOffset();\n            return region;\n        } else if (type == spine.AttachmentType.boundingbox)\n        {\n            var attachment = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n            var vertices = map[\"vertices\"];\n            for (var i = 0, n = vertices.length; i < n; i++)\n                attachment.vertices.push(vertices[i] * scale);\n            return attachment;\n        } else if (type == spine.AttachmentType.mesh || type == spine.AttachmentType.linkedmesh)\n        {\n            var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n            if (!mesh) return null;\n            mesh.path = path;\n            color = map[\"color\"];\n            if (color)\n            {\n                mesh.r = this.toColor(color, 0);\n                mesh.g = this.toColor(color, 1);\n                mesh.b = this.toColor(color, 2);\n                mesh.a = this.toColor(color, 3);\n            }\n            mesh.width = (map[\"width\"] || 0) * scale;\n            mesh.height = (map[\"height\"] || 0) * scale;\n\n            var parent = map[\"parent\"];\n            if (!parent) {\n                mesh.vertices = this.getFloatArray(map, \"vertices\", scale);\n                mesh.triangles = this.getIntArray(map, \"triangles\");\n                mesh.regionUVs = this.getFloatArray(map, \"uvs\", 1);\n                mesh.updateUVs();\n                mesh.hullLength = (map[\"hull\"] || 0) * 2;\n                if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\n            } else {\n                mesh.inheritFFD = !!map[\"ffd\"];\n                this.linkedMeshes.push(new LinkedMesh(mesh, map[\"skin\"] || null, slotIndex, parent));\n            }\n            return mesh;\n        } else if (type == spine.AttachmentType.weightedmesh || type == spine.AttachmentType.weightedlinkedmesh)\n        {\n            var mesh = this.attachmentLoader.newWeightedMeshAttachment(skin, name, path);\n            if (!mesh) return null;\n            mesh.path = path;\n            color = map[\"color\"];\n            if (color)\n            {\n                mesh.r = this.toColor(color, 0);\n                mesh.g = this.toColor(color, 1);\n                mesh.b = this.toColor(color, 2);\n                mesh.a = this.toColor(color, 3);\n            }\n            mesh.width = (map[\"width\"] || 0) * scale;\n            mesh.height = (map[\"height\"] || 0) * scale;\n\n            var parent = map[\"parent\"];\n            if (!parent) {\n                var uvs = this.getFloatArray(map, \"uvs\", 1);\n                var vertices = this.getFloatArray(map, \"vertices\", 1);\n                var weights = [];\n                var bones = [];\n                for (var i = 0, n = vertices.length; i < n; )\n                {\n                    var boneCount = vertices[i++] | 0;\n                    bones[bones.length] = boneCount;\n                    for (var nn = i + boneCount * 4; i < nn; )\n                    {\n                        bones[bones.length] = vertices[i];\n                        weights[weights.length] = vertices[i + 1] * scale;\n                        weights[weights.length] = vertices[i + 2] * scale;\n                        weights[weights.length] = vertices[i + 3];\n                        i += 4;\n                    }\n                }\n                mesh.bones = bones;\n                mesh.weights = weights;\n                mesh.triangles = this.getIntArray(map, \"triangles\");\n                mesh.regionUVs = uvs;\n                mesh.updateUVs();\n\n                mesh.hullLength = (map[\"hull\"] || 0) * 2;\n                if (map[\"edges\"]) mesh.edges = this.getIntArray(map, \"edges\");\n            } else {\n                mesh.inheritFFD = !!map[\"ffd\"];\n                this.linkedMeshes.push(new LinkedMesh(mesh, map[\"skin\"] || null, slotIndex, parent));\n            }\n            return mesh;\n        }\n        throw \"Unknown attachment type: \" + type;\n    },\n    readAnimation: function (name, map, skeletonData)\n    {\n        var timelines = [];\n        var duration = 0;\n\n        var slots = map[\"slots\"];\n        for (var slotName in slots)\n        {\n            if (!slots.hasOwnProperty(slotName)) continue;\n            var slotMap = slots[slotName];\n            var slotIndex = skeletonData.findSlotIndex(slotName);\n\n            for (var timelineName in slotMap)\n            {\n                if (!slotMap.hasOwnProperty(timelineName)) continue;\n                var values = slotMap[timelineName];\n                if (timelineName == \"color\")\n                {\n                    var timeline = new spine.ColorTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var color = valueMap[\"color\"];\n                        var r = this.toColor(color, 0);\n                        var g = this.toColor(color, 1);\n                        var b = this.toColor(color, 2);\n                        var a = this.toColor(color, 3);\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], r, g, b, a);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\n\n                } else if (timelineName == \"attachment\")\n                {\n                    var timeline = new spine.AttachmentTimeline(values.length);\n                    timeline.slotIndex = slotIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex++, valueMap[\"time\"], valueMap[\"name\"]);\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n\n                } else\n                    throw \"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\";\n            }\n        }\n\n        var bones = map[\"bones\"];\n        for (var boneName in bones)\n        {\n            if (!bones.hasOwnProperty(boneName)) continue;\n            var boneIndex = skeletonData.findBoneIndex(boneName);\n            if (boneIndex == -1) throw \"Bone not found: \" + boneName;\n            var boneMap = bones[boneName];\n\n            for (var timelineName in boneMap)\n            {\n                if (!boneMap.hasOwnProperty(timelineName)) continue;\n                var values = boneMap[timelineName];\n                if (timelineName == \"rotate\")\n                {\n                    var timeline = new spine.RotateTimeline(values.length);\n                    timeline.boneIndex = boneIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], valueMap[\"angle\"]);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 2 - 2]);\n\n                } else if (timelineName == \"translate\" || timelineName == \"scale\" || timelineName == \"shear\")\n                {\n                    var timeline;\n                    var timelineScale = 1;\n                    if (timelineName == \"scale\") {\n                        timeline = new spine.ScaleTimeline(values.length);\n                    } else if (timelineName == \"shear\") {\n                        timeline = new spine.ShearTimeline(values.length);\n                    }\n                    else\n                    {\n                        timeline = new spine.TranslateTimeline(values.length);\n                        timelineScale = this.scale;\n                    }\n                    timeline.boneIndex = boneIndex;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var x = (valueMap[\"x\"] || 0) * timelineScale;\n                        var y = (valueMap[\"y\"] || 0) * timelineScale;\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], x, y);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines.push(timeline);\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n\n                } else if (timelineName == \"flipX\" || timelineName == \"flipY\")\n                {\n                    throw \"flipX and flipY are not supported in spine v3: (\" + boneName + \")\";\n                } else\n                    throw \"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\";\n            }\n        }\n\n        var ikMap = map[\"ik\"];\n        for (var ikConstraintName in ikMap)\n        {\n            if (!ikMap.hasOwnProperty(ikConstraintName)) continue;\n            var ikConstraint = skeletonData.findIkConstraint(ikConstraintName);\n            var values = ikMap[ikConstraintName];\n            var timeline = new spine.IkConstraintTimeline(values.length);\n            timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(ikConstraint);\n            var frameIndex = 0;\n            for (var i = 0, n = values.length; i < n; i++)\n            {\n                var valueMap = values[i];\n                var mix = valueMap.hasOwnProperty(\"mix\") ? valueMap[\"mix\"] : 1;\n                var bendDirection = (!valueMap.hasOwnProperty(\"bendPositive\") || valueMap[\"bendPositive\"]) ? 1 : -1;\n                timeline.setFrame(frameIndex, valueMap[\"time\"], mix, bendDirection);\n                this.readCurve(timeline, frameIndex, valueMap);\n                frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 3 - 3]);\n        }\n\n        var transformMap = map[\"transform\"];\n        for (var transformConstraintName in transformMap)\n        {\n            if (!transformMap.hasOwnProperty(transformConstraintName)) continue;\n            var transformConstraint = skeletonData.findTransformConstraint(transformConstraintName);\n            var values = transformMap[transformConstraintName];\n            var timeline = new spine.TransformConstraintTimeline(values.length);\n            timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(transformConstraint);\n            var frameIndex = 0;\n            for (var i = 0, n = values.length; i < n; i++)\n            {\n                var valueMap = values[i];\n                var rotateMix = valueMap.hasOwnProperty(\"rotateMix\") ? valueMap[\"rotateMix\"] : 1;\n                var translateMix = valueMap.hasOwnProperty(\"translateMix\") ? valueMap[\"translateMix\"] : 1;\n                var scaleMix = valueMap.hasOwnProperty(\"scaleMix\") ? valueMap[\"scaleMix\"] : 1;\n                var shearMix = valueMap.hasOwnProperty(\"shearMix\") ? valueMap[\"shearMix\"] : 1;\n                timeline.setFrame(frameIndex, valueMap[\"time\"], translateMix, scaleMix, shearMix);\n                this.readCurve(timeline, frameIndex, valueMap);\n                frameIndex++;\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() * 5 - 5]);\n        }\n\n        var ffd = map[\"ffd\"];\n        for (var skinName in ffd)\n        {\n            var skin = skeletonData.findSkin(skinName);\n            var slotMap = ffd[skinName];\n            for (slotName in slotMap)\n            {\n                var slotIndex = skeletonData.findSlotIndex(slotName);\n                var meshMap = slotMap[slotName];\n                for (var meshName in meshMap)\n                {\n                    var values = meshMap[meshName];\n                    var timeline = new spine.FfdTimeline(values.length);\n                    var attachment = skin.getAttachment(slotIndex, meshName);\n                    if (!attachment) throw \"FFD attachment not found: \" + meshName;\n                    timeline.slotIndex = slotIndex;\n                    timeline.attachment = attachment;\n\n                    var isMesh = attachment.type == spine.AttachmentType.mesh;\n                    var vertexCount;\n                    if (isMesh)\n                        vertexCount = attachment.vertices.length;\n                    else\n                        vertexCount = attachment.weights.length / 3 * 2;\n\n                    var frameIndex = 0;\n                    for (var i = 0, n = values.length; i < n; i++)\n                    {\n                        var valueMap = values[i];\n                        var vertices;\n                        if (!valueMap[\"vertices\"])\n                        {\n                            if (isMesh)\n                                vertices = attachment.vertices;\n                            else\n                            {\n                                vertices = [];\n                                for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\n                            }\n                        } else {\n                            var verticesValue = valueMap[\"vertices\"];\n                            vertices = [];\n                            for (var j = 0; j < vertexCount; ++j) vertices.push(0); //initialize to 0\n                            var start = valueMap[\"offset\"] || 0;\n                            var nn = verticesValue.length;\n                            if (this.scale == 1)\n                            {\n                                for (var ii = 0; ii < nn; ii++)\n                                    vertices[ii + start] = verticesValue[ii];\n                            } else {\n                                for (var ii = 0; ii < nn; ii++)\n                                    vertices[ii + start] = verticesValue[ii] * this.scale;\n                            }\n                            if (isMesh)\n                            {\n                                var meshVertices = attachment.vertices;\n                                for (var ii = 0, nn = vertices.length; ii < nn; ii++)\n                                    vertices[ii] += meshVertices[ii];\n                            }\n                        }\n\n                        timeline.setFrame(frameIndex, valueMap[\"time\"], vertices);\n                        this.readCurve(timeline, frameIndex, valueMap);\n                        frameIndex++;\n                    }\n                    timelines[timelines.length] = timeline;\n                    duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n                }\n            }\n        }\n\n        var drawOrderValues = map[\"drawOrder\"];\n        if (!drawOrderValues) drawOrderValues = map[\"draworder\"];\n        if (drawOrderValues)\n        {\n            var timeline = new spine.DrawOrderTimeline(drawOrderValues.length);\n            var slotCount = skeletonData.slots.length;\n            var frameIndex = 0;\n            for (var i = 0, n = drawOrderValues.length; i < n; i++)\n            {\n                var drawOrderMap = drawOrderValues[i];\n                var drawOrder = null;\n                if (drawOrderMap[\"offsets\"])\n                {\n                    drawOrder = [];\n                    drawOrder.length = slotCount;\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\n                        drawOrder[ii] = -1;\n                    var offsets = drawOrderMap[\"offsets\"];\n                    var unchanged = [];\n                    unchanged.length = slotCount - offsets.length;\n                    var originalIndex = 0, unchangedIndex = 0;\n                    for (var ii = 0, nn = offsets.length; ii < nn; ii++)\n                    {\n                        var offsetMap = offsets[ii];\n                        var slotIndex = skeletonData.findSlotIndex(offsetMap[\"slot\"]);\n                        if (slotIndex == -1) throw \"Slot not found: \" + offsetMap[\"slot\"];\n                        // Collect unchanged items.\n                        while (originalIndex != slotIndex)\n                            unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap[\"offset\"]] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount)\n                        unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (var ii = slotCount - 1; ii >= 0; ii--)\n                        if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frameIndex++, drawOrderMap[\"time\"], drawOrder);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        var events = map[\"events\"];\n        if (events)\n        {\n            var timeline = new spine.EventTimeline(events.length);\n            var frameIndex = 0;\n            for (var i = 0, n = events.length; i < n; i++)\n            {\n                var eventMap = events[i];\n                var eventData = skeletonData.findEvent(eventMap[\"name\"]);\n                if (!eventData) throw \"Event not found: \" + eventMap[\"name\"];\n                var event = new spine.Event(eventData);\n                event.intValue = eventMap.hasOwnProperty(\"int\") ? eventMap[\"int\"] : eventData.intValue;\n                event.floatValue = eventMap.hasOwnProperty(\"float\") ? eventMap[\"float\"] : eventData.floatValue;\n                event.stringValue = eventMap.hasOwnProperty(\"string\") ? eventMap[\"string\"] : eventData.stringValue;\n                timeline.setFrame(frameIndex++, eventMap[\"time\"], event);\n            }\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        skeletonData.animations.push(new spine.Animation(name, timelines, duration));\n    },\n    readCurve: function (timeline, frameIndex, valueMap)\n    {\n        var curve = valueMap[\"curve\"];\n        if (!curve)\n            timeline.curves.setLinear(frameIndex);\n        else if (curve == \"stepped\")\n            timeline.curves.setStepped(frameIndex);\n        else if (curve instanceof Array)\n            timeline.curves.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n    },\n    toColor: function (hexString, colorIndex)\n    {\n        if (hexString.length != 8) throw \"Color hexidecimal length must be 8, recieved: \" + hexString;\n        return parseInt(hexString.substring(colorIndex * 2, (colorIndex * 2) + 2), 16) / 255;\n    },\n    getFloatArray: function (map, name, scale)\n    {\n        var list = map[name];\n        var values = new spine.Float32Array(list.length);\n        var i = 0, n = list.length;\n        if (scale == 1)\n        {\n            for (; i < n; i++)\n                values[i] = list[i];\n        } else {\n            for (; i < n; i++)\n                values[i] = list[i] * scale;\n        }\n        return values;\n    },\n    getIntArray: function (map, name)\n    {\n        var list = map[name];\n        var values = new spine.Uint16Array(list.length);\n        for (var i = 0, n = list.length; i < n; i++)\n            values[i] = list[i] | 0;\n        return values;\n    }\n};\nmodule.exports = spine.SkeletonJsonParser;\n\n","var spine = require('../SpineUtil');\nspine.Skin = function (name)\n{\n    this.name = name;\n    this.attachments = {};\n};\nspine.Skin.prototype = {\n    addAttachment: function (slotIndex, name, attachment)\n    {\n        this.attachments[slotIndex + \":\" + name] = attachment;\n    },\n    getAttachment: function (slotIndex, name)\n    {\n        return this.attachments[slotIndex + \":\" + name];\n    },\n    _attachAll: function (skeleton, oldSkin)\n    {\n        for (var key in oldSkin.attachments)\n        {\n            var colon = key.indexOf(\":\");\n            var slotIndex = parseInt(key.substring(0, colon));\n            var name = key.substring(colon + 1);\n            var slot = skeleton.slots[slotIndex];\n            if (slot.attachment && (slot.attachment.name === name) || (slot.data.attachmentName === name))\n            {\n                var attachment = this.getAttachment(slotIndex, name);\n                if (attachment) slot.setAttachment(attachment);\n            }\n        }\n    }\n};\nmodule.exports = spine.Skin;\n\n","var spine = require('../SpineUtil');\nspine.Slot = function (slotData, bone)\n{\n    this.data = slotData;\n    this.bone = bone;\n    this.setToSetupPose();\n};\nspine.Slot.prototype = {\n    r: 1, g: 1, b: 1, a: 1,\n    _attachmentTime: 0,\n    attachment: null,\n    attachmentVertices: [],\n    setAttachment: function (attachment)\n    {\n        this.attachment = attachment;\n        this._attachmentTime = this.bone.skeleton.time;\n        this.attachmentVertices.length = 0;\n    },\n    setAttachmentTime: function (time)\n    {\n        this._attachmentTime = this.bone.skeleton.time - time;\n    },\n    getAttachmentTime: function ()\n    {\n        return this.bone.skeleton.time - this._attachmentTime;\n    },\n    setToSetupPose: function ()\n    {\n        var data = this.data;\n        this.r = data.r;\n        this.g = data.g;\n        this.b = data.b;\n        this.a = data.a;\n        this.blendMode = data.blendMode;\n\n        var slotDatas = this.bone.skeleton.data.slots;\n        for (var i = 0, n = slotDatas.length; i < n; i++)\n        {\n            if (slotDatas[i] == data)\n            {\n                this.setAttachment(!data.attachmentName ? null : this.bone.skeleton.getAttachmentBySlotIndex(i, data.attachmentName));\n                break;\n            }\n        }\n    }\n};\nmodule.exports = spine.Slot;\n\n","var spine = require('../SpineUtil');\nspine.SlotData = function (name, boneData)\n{\n    this.name = name;\n    this.boneData = boneData;\n};\n\nspine.SlotData.PIXI_BLEND_MODE_MAP = {\n    'multiply': PIXI.BLEND_MODES.MULTIPLY,\n    'screen': PIXI.BLEND_MODES.SCREEN,\n    'additive': PIXI.BLEND_MODES.ADD,\n    'normal': PIXI.BLEND_MODES.NORMAL\n};\n\nspine.SlotData.prototype = {\n    r: 1, g: 1, b: 1, a: 1,\n    attachmentName: null,\n    blendMode: PIXI.BLEND_MODES.NORMAL\n\n\n};\n\n\nmodule.exports = spine.SlotData;\n\n","var spine = require('../SpineUtil');\nspine.TrackEntry = function ()\n{};\nspine.TrackEntry.prototype = {\n    next: null, previous: null,\n    animation: null,\n    loop: false,\n    delay: 0, time: 0, lastTime: -1, endTime: 0,\n    timeScale: 1,\n    mixTime: 0, mixDuration: 0, mix: 1,\n    onStart: null, onEnd: null, onComplete: null, onEvent: null\n};\nmodule.exports = spine.TrackEntry;\n\n","var spine = require('../SpineUtil');\nvar tempVec = [0, 0];\nspine.TransformConstraint = function (data, skeleton)\n{\n    this.data = data;\n    this.translateMix = data.translateMix;\n    this.rotateMix = data.rotateMix;\n    this.scaleMix = data.scaleMix;\n    this.shearMix = data.shearMix;\n    this.offsetX = data.offsetX;\n    this.offsetY = data.offsetY;\n    this.offsetScaleX = data.offsetScaleX;\n    this.offsetScaleY = data.offsetScaleY;\n    this.offsetShearY = data.offsetShearY;\n\n    this.bone = skeleton.findBone(data.bone.name);\n    this.target = skeleton.findBone(data.target.name);\n};\n\nspine.TransformConstraint.prototype = {\n    update: function() {\n        this.apply();\n    },\n    apply: function ()\n    {\n        var bm = this.bone.matrix;\n        var tm = this.target.matrix;\n\n        var rotateMix = this.rotateMix;\n        if (rotateMix > 0) {\n            var a = bm.a, b = bm.c, c = bm.b, d = bm.d;\n            var r = Math.atan2(tm.b, tm.a) - Math.atan2(c, a);\n            if (r > Math.PI)\n                r -= Math.PI*2;\n            else if (r < -Math.PI) r += Math.PI*2;\n            r *= rotateMix;\n            var cos = Math.cos(r), sin = Math.sin(r);\n            bm.a = cos * a - sin * c;\n            bm.c = cos * b - sin * d;\n            bm.b = sin * a + cos * c;\n            bm.d = sin * b + cos * d;\n        }\n\n        var scaleMix = this.rotateMix;\n        if (scaleMix > 0) {\n            var bs = Math.sqrt(bm.a * bm.a + bm.b * bm.b);\n            var ts = Math.sqrt(tm.a * tm.a + tm.b * tm.b);\n            var s = bs > 0.00001 ? (bs + (ts - bs + this.offsetScaleX) * scaleMix) / bs : 0;\n            bm.a *= s;\n            bm.b *= s;\n            bs = Math.sqrt(bm.c * bm.c + bm.d * bm.d);\n            ts = Math.sqrt(bm.c * bm.c + bm.d * bm.d);\n            s = bs > 0.00001 ? (bs + (ts - bs + this.offsetScaleY) * scaleMix) / bs : 0;\n            bm.c *= s;\n            bm.d *= s;\n        }\n\n        var shearMix = this.shearMix;\n        if (shearMix > 0) {\n            var b = bm.c, d = bm.d;\n            var by = Math.atan2(d, b);\n            var r = Math.atan2(tm.d, tm.c) - Math.atan2(tm.b, target.a) - (by - Math.atan2(bm.b, bm.a));\n            if (r > Math.PI)\n                r -= Math.PI*2;\n            else if (r < -Math.PI) r += Math.PI*2;\n            r = by + (r + this.offsetShearY * spine.degRad) * shearMix;\n            var s = Math.sqrt(b * b + d * d);\n            bm.c = Math.cos(r) * s;\n            bm.d = Math.sin(r) * s;\n        }\n\n        var translateMix = this.translateMix;\n        if (translateMix > 0) {\n            tempVec[0] = this.offsetX;\n            tempVec[1] = this.offsetY;\n            this.target.localToWorld(tempVec);\n            bm.tx += (tempVec[0] - bm.tx) * translateMix;\n            bm.ty += (tempVec[1] - bm.ty) * translateMix;\n        }\n    }\n};\n\nmodule.exports = spine.TransformConstraint;\n","var spine = require('../SpineUtil') || {};\nspine.TransformConstraintData = function (name)\n{\n    this.name = name;\n    this.bone = null;\n};\nspine.TransformConstraintData.prototype = {\n    target: null,\n    rotateMix: 1,\n    translateMix: 1,\n    scaleMix: 1,\n    shearMix: 1,\n    offsetRotation: 0,\n    offsetX: 0,\n    offsetY: 0,\n    offsetScaleX: 0,\n    offsetScaleY: 0,\n    offsetShearY: 0\n};\nmodule.exports = spine.TransformConstraintData;\n\n","var spine = require('../SpineUtil') || {};\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.TransformConstraintTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, mix, bendDirection, ...\n    this.frames.length = frameCount * 3;\n};\nspine.TransformConstraintTimeline.prototype = {\n    transformConstraintIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length / 5;\n    },\n    setFrame: function (frameIndex, time, rotateMix, translateMix, scaleMix, shareMix)\n    {\n        frameIndex *= 5;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = rotateMix;\n        this.frames[frameIndex + 2] = translateMix;\n        this.frames[frameIndex + 3] = scaleMix;\n        this.frames[frameIndex + 4] = shareMix;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var constraint = skeleton.transformConstraints[this.transformConstraintIndex];\n\n        if (time >= frames[frames.length - 5])\n        { // Time is after last frame.\n            constraint.rotateMix += (frames[i - 3] - constraint.rotateMix) * alpha;\n            constraint.translateMix += (frames[i - 2] - constraint.translateMix) * alpha;\n            constraint.scaleMix += (frames[i - 1] - constraint.scaleMix) * alpha;\n            constraint.shearMix += (frames[i] - constraint.shearMix) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frame = spine.Animation.binarySearch(frames, time, 5);\n        var frameTime = frames[frame];\n        var percent = 1 - (time - frameTime) / (frames[frame + -5/*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frame / 5 - 1, percent);\n\n        var rotate = frames[frame + -4/*PREV_ROTATE_MIX*/];\n        var translate = frames[frame + -3/*PREV_TRANSLATE_MIX*/];\n        var scale = frames[frame + -2/*PREV_SCALE_MIX*/];\n        var shear = frames[frame + -1/*PREV_SHEAR_MIX*/];\n        constraint.rotateMix += (rotate + (frames[frame + 1/*ROTATE_MIX*/] - rotate) * percent - constraint.rotateMix) * alpha;\n        constraint.translateMix += (translate + (frames[frame + 2/*TRANSLATE_MIX*/] - translate) * percent - constraint.translateMix)\n            * alpha;\n        constraint.scaleMix += (scale + (frames[frame + 3/*SCALE_MIX*/] - scale) * percent - constraint.scaleMix) * alpha;\n        constraint.shearMix += (shear + (frames[frame + 4/*SHEAR_MIX*/] - shear) * percent - constraint.shearMix) * alpha;\n    }\n};\nmodule.exports = spine.TransformConstraintTimeline;\n\n","var spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.Curves = require('./Curves');\nspine.TranslateTimeline = function (frameCount)\n{\n    this.curves = new spine.Curves(frameCount);\n    this.frames = []; // time, x, y, ...\n    this.frames.length = frameCount * 3;\n};\nspine.TranslateTimeline.prototype = {\n    boneIndex: 0,\n    getFrameCount: function ()\n    {\n        return this.frames.length / 3;\n    },\n    setFrame: function (frameIndex, time, x, y)\n    {\n        frameIndex *= 3;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + 1] = x;\n        this.frames[frameIndex + 2] = y;\n    },\n    apply: function (skeleton, lastTime, time, firedEvents, alpha)\n    {\n        var frames = this.frames;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time >= frames[frames.length - 3])\n        { // Time is after last frame.\n            bone.x += (bone.data.x + frames[frames.length - 2] - bone.x) * alpha;\n            bone.y += (bone.data.y + frames[frames.length - 1] - bone.y) * alpha;\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        var frameIndex = spine.Animation.binarySearch(frames, time, 3);\n        var prevFrameX = frames[frameIndex - 2];\n        var prevFrameY = frames[frameIndex - 1];\n        var frameTime = frames[frameIndex];\n        var percent = 1 - (time - frameTime) / (frames[frameIndex + -3/*PREV_FRAME_TIME*/] - frameTime);\n        percent = this.curves.getCurvePercent(frameIndex / 3 - 1, percent);\n\n        bone.x += (bone.data.x + prevFrameX + (frames[frameIndex + 1/*FRAME_X*/] - prevFrameX) * percent - bone.x) * alpha;\n        bone.y += (bone.data.y + prevFrameY + (frames[frameIndex + 2/*FRAME_Y*/] - prevFrameY) * percent - bone.y) * alpha;\n    }\n};\nmodule.exports = spine.TranslateTimeline;\n\n","var spine = require('../SpineUtil') || {};\nspine.AttachmentType = require('./AttachmentType');\nspine.WeightedMeshAttachment = function (name)\n{\n    this.name = name;\n};\nspine.WeightedMeshAttachment.prototype = {\n    type: spine.AttachmentType.weightedmesh,\n    parentMesh: null,\n    inheritFFD: false,\n    bones: null,\n    weights: null,\n    uvs: null,\n    regionUVs: null,\n    triangles: null,\n    hullLength: 0,\n    r: 1, g: 1, b: 1, a: 1,\n    path: null,\n    rendererObject: null,\n    edges: null,\n    width: 0, height: 0,\n    updateUVs: function (u, v, u2, v2, rotate)\n    {\n        var width = this.regionU2 - this.regionU, height = this.regionV2 - this.regionV;\n        var n = this.regionUVs.length;\n        if (!this.uvs || this.uvs.length != n)\n        {\n            this.uvs = new spine.Float32Array(n);\n        }\n        var region = this.rendererObject;\n        if (!region) return;\n        var texture = region.texture;\n        var r = texture._uvs;\n        var w1 = region.width, h1 = region.height, w2 = region.originalWidth, h2 = region.originalHeight;\n        var x = region.offsetX, y = region.pixiOffsetY;\n        for (var i = 0; i < n; i += 2)\n        {\n            var u = this.regionUVs[i], v = this.regionUVs[i+1];\n            u = (u * w2 - x) / w1;\n            v = (v * h2 - y) / h1;\n            this.uvs[i] = (r.x0 * (1 - u) + r.x1 * u) * (1-v) + (r.x3 * (1 - u) + r.x2 * u) * v;\n            this.uvs[i+1] = (r.y0 * (1 - u) + r.y1 * u) * (1-v) + (r.y3 * (1 - u) + r.y2 * u) * v;\n        }\n    },\n    computeWorldVertices: function (x, y, slot, worldVertices)\n    {\n        var skeletonBones = slot.bone.skeleton.bones;\n        var weights = this.weights;\n        var bones = this.bones;\n\n        var w = 0, v = 0, b = 0, f = 0, n = bones.length, nn;\n        var wx, wy, vx, vy, weight;\n        var m;\n        if (!slot.attachmentVertices.length)\n        {\n            for (; v < n; w += 2)\n            {\n                wx = 0;\n                wy = 0;\n                nn = bones[v++] + v;\n                for (; v < nn; v++, b += 3)\n                {\n                    m = skeletonBones[bones[v]].matrix;\n                    vx = weights[b];\n                    vy = weights[b + 1];\n                    weight = weights[b + 2];\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\n                }\n                worldVertices[w] = wx + x;\n                worldVertices[w + 1] = wy + y;\n            }\n        } else {\n            var ffd = slot.attachmentVertices;\n            for (; v < n; w += 2)\n            {\n                wx = 0;\n                wy = 0;\n                nn = bones[v++] + v;\n                for (; v < nn; v++, b += 3, f += 2)\n                {\n                    m = skeletonBones[bones[v]].matrix;\n                    vx = weights[b] + ffd[f];\n                    vy = weights[b + 1] + ffd[f + 1];\n                    weight = weights[b + 2];\n                    wx += (vx * m.a + vy * m.c + m.tx) * weight;\n                    wy += (vx * m.b + vy * m.d + m.ty) * weight;\n                }\n                worldVertices[w] = wx + x;\n                worldVertices[w + 1] = wy + y;\n            }\n        }\n    },\n    applyFFD: function(sourceAttachment) {\n        return this === sourceAttachment || (this.inheritFFD && parentMesh === sourceAttachment);\n    },\n    setParentMesh: function(parentMesh) {\n        this.parentMesh = parentMesh;\n        if (parentMesh != null) {\n            this.bones = parentMesh.bones;\n            this.weights = parentMesh.weights;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n        }\n    }\n};\nmodule.exports = spine.WeightedMeshAttachment;\n\n","/******************************************************************************\n * Spine Runtimes Software License\n * Version 2.1\n *\n * Copyright (c) 2013, Esoteric Software\n * All rights reserved.\n *\n * You are granted a perpetual, non-exclusive, non-sublicensable and\n * non-transferable license to install, execute and perform the Spine Runtimes\n * Software (the \"Software\") solely for internal use. Without the written\n * permission of Esoteric Software (typically granted by licensing Spine), you\n * may not (a) modify, translate, adapt or otherwise create derivative works,\n * improvements of the Software or develop new applications using the Software\n * or (b) remove, delete, alter or obscure any trademarks or any copyright,\n * trademark, patent or other intellectual property or proprietary rights\n * notices on or in the Software, including any copy thereof. Redistributions\n * in binary or source form must include this license and terms.\n *\n * THIS SOFTWARE IS PROVIDED BY ESOTERIC SOFTWARE \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL ESOTERIC SOFTARE BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\nvar spine = require('../SpineUtil');\nspine.Animation = require('./Animation');\nspine.AnimationStateData = require('./AnimationStateData');\nspine.AnimationState = require('./AnimationState');\nspine.AtlasAttachmentParser = require('./AtlasAttachmentParser');\nspine.Atlas = require('./Atlas');\nspine.AtlasPage = require('./AtlasPage');\nspine.AtlasReader = require('./AtlasReader');\nspine.AtlasRegion = require('./AtlasRegion');\nspine.AttachmentTimeline = require('./AttachmentTimeline');\nspine.AttachmentType = require('./AttachmentType');\nspine.BoneData = require('./BoneData');\nspine.Bone = require('./Bone');\nspine.BoundingBoxAttachment = require('./BoundingBoxAttachment');\nspine.ColorTimeline = require('./ColorTimeline');\nspine.Curves = require('./Curves');\nspine.DrawOrderTimeline = require('./DrawOrderTimeline');\nspine.EventData = require('./EventData');\nspine.Event = require('./Event');\nspine.EventTimeline = require('./EventTimeline');\nspine.FfdTimeline = require('./FfdTimeline');\nspine.IkConstraintData = require('./IkConstraintData');\nspine.IkConstraint = require('./IkConstraint');\nspine.IkConstraintTimeline = require('./IkConstraintTimeline');\nspine.TransformConstraintData = require('./TransformConstraintData');\nspine.TransformConstraint = require('./TransformConstraint');\nspine.TransformConstraintTimeline = require('./TransformConstraintTimeline');\nspine.MeshAttachment = require('./MeshAttachment');\nspine.RegionAttachment = require('./RegionAttachment');\nspine.RotateTimeline = require('./RotateTimeline');\nspine.ScaleTimeline = require('./ScaleTimeline');\nspine.ShearTimeline = require('./ShearTimeline');\nspine.SkeletonBounds = require('./SkeletonBounds');\nspine.SkeletonData = require('./SkeletonData');\nspine.Skeleton = require('./Skeleton');\nspine.SkeletonJsonParser = require('./SkeletonJsonParser');\nspine.Skin = require('./Skin.js');\nspine.WeightedMeshAttachment = require('./WeightedMeshAttachment');\nspine.SlotData = require('./SlotData');\nspine.Slot = require('./Slot');\nspine.TrackEntry = require('./TrackEntry');\nspine.TranslateTimeline = require('./TranslateTimeline');\nmodule.exports = spine;\n","module.exports = {\n    radDeg: 180 / Math.PI,\n    degRad: Math.PI / 180,\n    temp: [],\n    Float32Array: (typeof(Float32Array) === 'undefined') ? Array : Float32Array,\n    Uint16Array: (typeof(Uint16Array) === 'undefined') ? Array : Uint16Array,\n    signum: function(x) {\n        if (x>0) return 1;\n        if (x<0) return -1;\n        return 0;\n    }\n};\n\n","/**\n * @file        Spine resource loader\n * @author      Ivan Popelyshev <ivan.popelyshev@gmail.com>\n * @copyright   2013-2015 GoodBoyDigital\n * @license     {@link https://github.com/GoodBoyDigital/pixi.js/blob/master/LICENSE|MIT License}\n */\n\n/**\n * @namespace PIXI.loaders\n */\n\nvar atlasParser = require('./atlasParser');\n\nPIXI.loaders.Loader.addPixiMiddleware(atlasParser);\nPIXI.loader.use(atlasParser());\n","var Resource = PIXI.loaders.Resource,\n    spine = require('../SpineRuntime'),\n    imageLoaderAdapter = require('./imageLoaderAdapter');\n\nvar atlasParser = module.exports = function () {\n    return function (resource, next) {\n        // skip if no data, its not json, or it isn't atlas data\n        if (!resource.data || !resource.isJson || !resource.data.bones) {\n            return next();\n        }\n\n        var metadataAtlas = resource.metadata ? resource.metadata.spineAtlas: null;\n        if (metadataAtlas === false) {\n            return next();\n        }\n        if (metadataAtlas && metadataAtlas.pages) {\n            //its an atlas!\n            var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(metadataAtlas));\n            var skeletonData = spineJsonParser.readSkeletonData(resource.data);\n\n            resource.spineData = skeletonData;\n            resource.spineAtlas = metadataAtlas;\n            if (atlasParser.enableCaching) {\n                atlasParser.AnimCache[resource.name] = resource.spineData;\n            }\n\n            next();\n        }\n\n        /**\n         * use a bit of hackery to load the atlas file, here we assume that the .json, .atlas and .png files\n         * that correspond to the spine file are in the same base URL and that the .json and .atlas files\n         * have the same name\n         */\n        var atlasPath = resource.url.substr(0, resource.url.lastIndexOf('.')) + '.atlas';\n        //remove the baseUrl\n        atlasPath = atlasPath.replace(this.baseUrl, '');\n\n        var atlasOptions = {\n            crossOrigin: resource.crossOrigin,\n            xhrType: Resource.XHR_RESPONSE_TYPE.TEXT,\n            metadata: resource.metadata ? resource.metadata.spineMetadata : null\n        };\n        var imageOptions = {\n            crossOrigin: resource.crossOrigin,\n            metadata: resource.metadata ? resource.metadata.imageMetadata: null\n        };\n        var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\n        //remove the baseUrl\n        baseUrl = baseUrl.replace(this.baseUrl, '');\n\n        var adapter = imageLoaderAdapter(this, resource.name + '_atlas_page_', baseUrl, imageOptions);\n\n        this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (res) {\n            new spine.Atlas(this.xhr.responseText, adapter, function(spineAtlas) {\n                var spineJsonParser = new spine.SkeletonJsonParser(new spine.AtlasAttachmentParser(spineAtlas));\n                var skeletonData = spineJsonParser.readSkeletonData(resource.data);\n\n                resource.spineData = skeletonData;\n                resource.spineAtlas = spineAtlas;\n                if (atlasParser.enableCaching) {\n                    atlasParser.AnimCache[resource.name] = resource.spineData;\n                }\n\n                next();\n            });\n        });\n    };\n};\n\natlasParser.AnimCache = {};\natlasParser.enableCaching = false;\n","var spine = require('../SpineRuntime');\n\nmodule.exports = function (loader, namePrefix, baseUrl, imageOptions) {\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\n    {\n        baseUrl += '/';\n    }\n    return function(line, callback) {\n        var name = namePrefix + line;\n        var url = baseUrl + line;\n        loader.add(name, url, imageOptions, function(resource) {\n            callback(resource.texture.baseTexture);\n        });\n    }\n};\n","module.exports = {\n    atlasParser: require('./atlasParser'),\n    Loader: require('./Loader'),\n    syncImageLoaderAdapter: require('./syncImageLoaderAdapter'),\n    imageLoaderAdapter: require('./imageLoaderAdapter')\n};\n","var spine = require('../SpineRuntime');\n\nmodule.exports = function (baseUrl, crossOrigin) {\n    if (baseUrl && baseUrl.lastIndexOf('/') !== (baseUrl.length-1))\n    {\n        baseUrl += '/';\n    }\n    return function(line, callback) {\n        callback(PIXI.BaseTexture.fromImage(line, crossOrigin));\n    }\n};\n"],"sourceRoot":"./"}